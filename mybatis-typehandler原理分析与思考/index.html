<!doctype html><html lang=en-US><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://barryoo.github.io/favicon.ico><title>mybatis TypeHandler原理分析与思考 | Barry Blog</title>
<meta name=title content="mybatis TypeHandler原理分析与思考"><meta name=description content="TypeHandler使用 在自定义TypeHandler上注解@MappedTypes(value = {A.class, B.class}) 配置typeHandlersPackage. 包下的所有TypeHandler都会被自动注册. Mapper.xml中声明<result column=&#34;enum1&#34; jdbcType=&#34;INTEGER&#34; typeHandler=&#34;xxx&#34;/> mybatis配置文件 <typeHandlers> <typeHandler handler=&#34;com.xxx.handler.EnumTypeHandler&#34;/> </typeHandlers> TypeHandler工作原理 自动注册JavaType的所有默认TypeHandler. 见TypeHandlerRegistry 虽然Enum不是JavaType, 但是会自动设置默认的EnumTypeHandler. 在根据javaType获取TypeHandler的时候, 会判断class是否是enum, 如果是, 则会生成该enum专用的EnumTypeHandler TypeHandler注册时,需要寻找对应的JavaType. 如果已经指定JavaType, 则直接可以注册 如果没有指定, 则尝试通过@MappedTypes注解, 找到JavaType 如果依然找不到JavaType, 则判断该TypeHandler是否继承TypeReference<T>,通过getSuperclassTypeParameter方法,可以得到泛型的JavaType. 如果依然找不到JavaType, 则JavaType为null,进行注册. preparedStatement设值时, 调用来字段对应的HandlerType,进行转换. 查询数据库结果后, 调用字段对应的HandlerType.setResult. mybatis中对于Enum的类型处理 使用者什么都不用做, 自动支持.
mybatis提供了EnumTypeHandler和EnumOrdinalTypeHandler.
EnumTypeHandler: 调用Enum.name()方法, 将枚举转换为String. EnumOrdinalTypeHandler: 调用Enum.ordinal()方法, 将枚举转换为int. 当需要转换枚举类型时, 优先使用缓存中的TypeHandler, 如果没有找到, 则实时生成专用的EnumTypeHandler.
MybatisPlusEnumTypeHandler MybatisPlus通过MybaitsEnumTypeHandler增强对enum的支持,允许指定转换时使用的字段.
使用 配置mybatis-plus.defaultEnumTypeHandler, 默认是org.apache.ibatis.type.EnumTypeHandler, 可以不配置. 如果想要在初始化时, 创建TypeHandler, 有两种方式 配置mybatis-plus.type-enums-package. 自动为该包下的所有enum,注册MybatisPlusEnumTypeHandler. 在model中为枚举字段注解@TableField(typeHandler = xxx), 为该枚举,注册指定的TypeHandler. 如果想要在使用时, 实时创建Typehandler. 枚举实现IEnum接口,或者为想要序列化的字段设置@EnumValue注解."><meta name=keywords content="Mybatis,泛型,"><meta property="og:title" content="mybatis TypeHandler原理分析与思考"><meta property="og:description" content="TypeHandler使用 在自定义TypeHandler上注解@MappedTypes(value = {A.class, B.class}) 配置typeHandlersPackage. 包下的所有TypeHandler都会被自动注册. Mapper.xml中声明<result column=&#34;enum1&#34; jdbcType=&#34;INTEGER&#34; typeHandler=&#34;xxx&#34;/> mybatis配置文件 <typeHandlers> <typeHandler handler=&#34;com.xxx.handler.EnumTypeHandler&#34;/> </typeHandlers> TypeHandler工作原理 自动注册JavaType的所有默认TypeHandler. 见TypeHandlerRegistry 虽然Enum不是JavaType, 但是会自动设置默认的EnumTypeHandler. 在根据javaType获取TypeHandler的时候, 会判断class是否是enum, 如果是, 则会生成该enum专用的EnumTypeHandler TypeHandler注册时,需要寻找对应的JavaType. 如果已经指定JavaType, 则直接可以注册 如果没有指定, 则尝试通过@MappedTypes注解, 找到JavaType 如果依然找不到JavaType, 则判断该TypeHandler是否继承TypeReference<T>,通过getSuperclassTypeParameter方法,可以得到泛型的JavaType. 如果依然找不到JavaType, 则JavaType为null,进行注册. preparedStatement设值时, 调用来字段对应的HandlerType,进行转换. 查询数据库结果后, 调用字段对应的HandlerType.setResult. mybatis中对于Enum的类型处理 使用者什么都不用做, 自动支持.
mybatis提供了EnumTypeHandler和EnumOrdinalTypeHandler.
EnumTypeHandler: 调用Enum.name()方法, 将枚举转换为String. EnumOrdinalTypeHandler: 调用Enum.ordinal()方法, 将枚举转换为int. 当需要转换枚举类型时, 优先使用缓存中的TypeHandler, 如果没有找到, 则实时生成专用的EnumTypeHandler.
MybatisPlusEnumTypeHandler MybatisPlus通过MybaitsEnumTypeHandler增强对enum的支持,允许指定转换时使用的字段.
使用 配置mybatis-plus.defaultEnumTypeHandler, 默认是org.apache.ibatis.type.EnumTypeHandler, 可以不配置. 如果想要在初始化时, 创建TypeHandler, 有两种方式 配置mybatis-plus.type-enums-package. 自动为该包下的所有enum,注册MybatisPlusEnumTypeHandler. 在model中为枚举字段注解@TableField(typeHandler = xxx), 为该枚举,注册指定的TypeHandler. 如果想要在使用时, 实时创建Typehandler. 枚举实现IEnum接口,或者为想要序列化的字段设置@EnumValue注解."><meta property="og:type" content="article"><meta property="og:url" content="https://barryoo.github.io/mybatis-typehandler%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83/"><meta property="og:image" content="https://barryoo.github.io/images/share.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2020-11-30T00:00:00+00:00"><meta property="article:modified_time" content="2020-11-30T00:00:00+00:00"><meta property="og:site_name" content="barry blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://barryoo.github.io/images/share.png"><meta name=twitter:title content="mybatis TypeHandler原理分析与思考"><meta name=twitter:description content="TypeHandler使用 在自定义TypeHandler上注解@MappedTypes(value = {A.class, B.class}) 配置typeHandlersPackage. 包下的所有TypeHandler都会被自动注册. Mapper.xml中声明<result column=&#34;enum1&#34; jdbcType=&#34;INTEGER&#34; typeHandler=&#34;xxx&#34;/> mybatis配置文件 <typeHandlers> <typeHandler handler=&#34;com.xxx.handler.EnumTypeHandler&#34;/> </typeHandlers> TypeHandler工作原理 自动注册JavaType的所有默认TypeHandler. 见TypeHandlerRegistry 虽然Enum不是JavaType, 但是会自动设置默认的EnumTypeHandler. 在根据javaType获取TypeHandler的时候, 会判断class是否是enum, 如果是, 则会生成该enum专用的EnumTypeHandler TypeHandler注册时,需要寻找对应的JavaType. 如果已经指定JavaType, 则直接可以注册 如果没有指定, 则尝试通过@MappedTypes注解, 找到JavaType 如果依然找不到JavaType, 则判断该TypeHandler是否继承TypeReference<T>,通过getSuperclassTypeParameter方法,可以得到泛型的JavaType. 如果依然找不到JavaType, 则JavaType为null,进行注册. preparedStatement设值时, 调用来字段对应的HandlerType,进行转换. 查询数据库结果后, 调用字段对应的HandlerType.setResult. mybatis中对于Enum的类型处理 使用者什么都不用做, 自动支持.
mybatis提供了EnumTypeHandler和EnumOrdinalTypeHandler.
EnumTypeHandler: 调用Enum.name()方法, 将枚举转换为String. EnumOrdinalTypeHandler: 调用Enum.ordinal()方法, 将枚举转换为int. 当需要转换枚举类型时, 优先使用缓存中的TypeHandler, 如果没有找到, 则实时生成专用的EnumTypeHandler.
MybatisPlusEnumTypeHandler MybatisPlus通过MybaitsEnumTypeHandler增强对enum的支持,允许指定转换时使用的字段.
使用 配置mybatis-plus.defaultEnumTypeHandler, 默认是org.apache.ibatis.type.EnumTypeHandler, 可以不配置. 如果想要在初始化时, 创建TypeHandler, 有两种方式 配置mybatis-plus.type-enums-package. 自动为该包下的所有enum,注册MybatisPlusEnumTypeHandler. 在model中为枚举字段注解@TableField(typeHandler = xxx), 为该枚举,注册指定的TypeHandler. 如果想要在使用时, 实时创建Typehandler. 枚举实现IEnum接口,或者为想要序列化的字段设置@EnumValue注解."><meta itemprop=name content="mybatis TypeHandler原理分析与思考"><meta itemprop=description content="TypeHandler使用 在自定义TypeHandler上注解@MappedTypes(value = {A.class, B.class}) 配置typeHandlersPackage. 包下的所有TypeHandler都会被自动注册. Mapper.xml中声明<result column=&#34;enum1&#34; jdbcType=&#34;INTEGER&#34; typeHandler=&#34;xxx&#34;/> mybatis配置文件 <typeHandlers> <typeHandler handler=&#34;com.xxx.handler.EnumTypeHandler&#34;/> </typeHandlers> TypeHandler工作原理 自动注册JavaType的所有默认TypeHandler. 见TypeHandlerRegistry 虽然Enum不是JavaType, 但是会自动设置默认的EnumTypeHandler. 在根据javaType获取TypeHandler的时候, 会判断class是否是enum, 如果是, 则会生成该enum专用的EnumTypeHandler TypeHandler注册时,需要寻找对应的JavaType. 如果已经指定JavaType, 则直接可以注册 如果没有指定, 则尝试通过@MappedTypes注解, 找到JavaType 如果依然找不到JavaType, 则判断该TypeHandler是否继承TypeReference<T>,通过getSuperclassTypeParameter方法,可以得到泛型的JavaType. 如果依然找不到JavaType, 则JavaType为null,进行注册. preparedStatement设值时, 调用来字段对应的HandlerType,进行转换. 查询数据库结果后, 调用字段对应的HandlerType.setResult. mybatis中对于Enum的类型处理 使用者什么都不用做, 自动支持.
mybatis提供了EnumTypeHandler和EnumOrdinalTypeHandler.
EnumTypeHandler: 调用Enum.name()方法, 将枚举转换为String. EnumOrdinalTypeHandler: 调用Enum.ordinal()方法, 将枚举转换为int. 当需要转换枚举类型时, 优先使用缓存中的TypeHandler, 如果没有找到, 则实时生成专用的EnumTypeHandler.
MybatisPlusEnumTypeHandler MybatisPlus通过MybaitsEnumTypeHandler增强对enum的支持,允许指定转换时使用的字段.
使用 配置mybatis-plus.defaultEnumTypeHandler, 默认是org.apache.ibatis.type.EnumTypeHandler, 可以不配置. 如果想要在初始化时, 创建TypeHandler, 有两种方式 配置mybatis-plus.type-enums-package. 自动为该包下的所有enum,注册MybatisPlusEnumTypeHandler. 在model中为枚举字段注解@TableField(typeHandler = xxx), 为该枚举,注册指定的TypeHandler. 如果想要在使用时, 实时创建Typehandler. 枚举实现IEnum接口,或者为想要序列化的字段设置@EnumValue注解."><meta itemprop=datePublished content="2020-11-30T00:00:00+00:00"><meta itemprop=dateModified content="2020-11-30T00:00:00+00:00"><meta itemprop=wordCount content="109"><meta itemprop=image content="https://barryoo.github.io/images/share.png"><meta itemprop=keywords content="Mybatis,泛型,"><meta name=referrer content="no-referrer-when-downgrade"><style>html{scroll-behavior:smooth}body{font-family:Verdana,sans-serif;margin:auto;padding:20px;text-align:left;background-color:#fff;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:#444}header{margin:auto;text-align:center;max-width:720px}.menu{justify-content:space-between;display:flex}main{margin:0 auto}.blog-posts-container{width:fit-content;margin:auto}.tag-container{max-width:720px}h1,h2,h3,h4,h5,h6,strong,b{color:#222}a{color:#3273dc}.title{text-decoration:none;border:0;text-align:center;color:#000;font-size:25px}.title span{font-weight:400}nav a{margin-right:10px}textarea{width:100%;font-size:16px}input{font-size:16px}.toc{max-width:250px;width:auto;top:20%;position:fixed;font-size:13px}.toc a{color:rgba(128,128,128,.4);text-decoration:none;display:block}.toc a:hover{color:#777}article{max-width:1080px;margin:0 auto;margin-left:calc(max((100% - 1080px)/2,250px))}content{line-height:1.6}table{width:100%}img{max-width:100%}code{padding:2px 5px;background-color:#f2f2f2}pre code{color:#222;display:block;padding:20px;white-space:pre-wrap;font-size:14px;overflow-x:auto}div.highlight pre{background-color:initial;color:initial}div.highlight code{background-color:unset;color:unset}blockquote{border-left:1px solid #999;color:#222;padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.helptext{color:#777;font-size:small}.errorlist{color:#eba613;font-size:small}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li span{margin-right:30px}ul.blog-posts li a:visited{color:#8b6fcb}@media(prefers-color-scheme:dark){body{background-color:#333;color:#ddd}h1,h2,h3,h4,h5,h6,strong,b{color:#eee}a{color:#8cc2dd}code{background-color:#777}pre code{color:#ddd}blockquote{color:#ccc}textarea,input{background-color:#252525;color:#ddd}.helptext{color:#aaa}}@media only screen and (max-width:1020px){.toc{width:auto;position:relative}article{padding-left:0;margin:0 auto}}</style></head><body><header><nav class=menu><a id=siteTitle href=/ class=title>Barry Blog</a><div style=display:flex><a href=/>Home</a>
<a href=https://github.com/barryOO>github</a>
<a href=/blog/>Blog</a></div></nav></header><main><aside class=toc><a href=#siteTitle style=margin-left:40px>top</a><nav id=TableOfContents><ul><li><a href=#typehandler使用>TypeHandler使用</a></li><li><a href=#typehandler工作原理>TypeHandler工作原理</a></li><li><a href=#mybatis中对于enum的类型处理>mybatis中对于Enum的类型处理</a></li><li><a href=#mybatisplusenumtypehandler>MybatisPlusEnumTypeHandler</a><ul><li><a href=#使用>使用</a></li><li><a href=#原理>原理</a></li></ul></li><li><a href=#mybatisplus中枚举处理的另一种方式>mybatisPlus中枚举处理的另一种方式</a></li><li><a href=#延伸>延伸</a></li></ul></nav></aside><article><h1 style=font-size:40px>mybatis TypeHandler原理分析与思考</h1><p><i><time datetime=2020-11-30 pubdate>30 Nov, 2020</time></i></p><p><a href=https://barryoo.github.io/blog/mybatis/>#Mybatis</a>
<a href=https://barryoo.github.io/blog/%E6%B3%9B%E5%9E%8B/>#泛型</a></p><content><h2 id=typehandler使用>TypeHandler使用</h2><ol><li>在自定义TypeHandler上注解@MappedTypes(value = {A.class, B.class})</li><li>配置<code>typeHandlersPackage</code>. 包下的所有TypeHandler都会被自动注册.</li><li>Mapper.xml中声明<code>&lt;result column="enum1" jdbcType="INTEGER" typeHandler="xxx"/></code></li><li>mybatis配置文件<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-xml data-lang=xml><span style=display:flex><span><span style=color:#f92672>&lt;typeHandlers&gt;</span>
</span></span><span style=display:flex><span>    <span style=color:#f92672>&lt;typeHandler</span> <span style=color:#a6e22e>handler=</span><span style=color:#e6db74>&#34;com.xxx.handler.EnumTypeHandler&#34;</span><span style=color:#f92672>/&gt;</span>
</span></span><span style=display:flex><span><span style=color:#f92672>&lt;/typeHandlers&gt;</span>
</span></span></code></pre></div></li></ol><h2 id=typehandler工作原理>TypeHandler工作原理</h2><ul><li>自动注册<code>JavaType</code>的所有默认TypeHandler. 见<code>TypeHandlerRegistry</code><ul><li>虽然Enum不是<code>JavaType</code>, 但是会自动设置默认的EnumTypeHandler. 在根据javaType获取TypeHandler的时候, 会判断class是否是enum, 如果是, 则会生成该enum专用的EnumTypeHandler</li></ul></li><li>TypeHandler注册时,需要寻找对应的JavaType.<ul><li>如果已经指定JavaType, 则直接可以注册</li><li>如果没有指定, 则尝试通过@MappedTypes注解, 找到JavaType</li><li>如果依然找不到JavaType, 则判断该TypeHandler是否继承<code>TypeReference&lt;T></code>,通过<code>getSuperclassTypeParameter</code>方法,可以得到泛型的JavaType.</li><li>如果依然找不到JavaType, 则JavaType为null,进行注册.</li></ul></li><li>preparedStatement设值时, 调用来字段对应的HandlerType,进行转换.</li><li>查询数据库结果后, 调用字段对应的HandlerType.setResult.</li></ul><h2 id=mybatis中对于enum的类型处理>mybatis中对于Enum的类型处理</h2><p>使用者什么都不用做, 自动支持.</p><p>mybatis提供了EnumTypeHandler和EnumOrdinalTypeHandler.</p><ul><li>EnumTypeHandler: 调用Enum.name()方法, 将枚举转换为String.</li><li>EnumOrdinalTypeHandler: 调用Enum.ordinal()方法, 将枚举转换为int.</li></ul><p>当需要转换枚举类型时, 优先使用缓存中的TypeHandler, 如果没有找到, 则实时生成专用的EnumTypeHandler.</p><h2 id=mybatisplusenumtypehandler>MybatisPlusEnumTypeHandler</h2><p>MybatisPlus通过<code>MybaitsEnumTypeHandler</code>增强对enum的支持,允许指定转换时使用的字段.</p><h3 id=使用>使用</h3><ul><li>配置<code>mybatis-plus.defaultEnumTypeHandler</code>, 默认是<code>org.apache.ibatis.type.EnumTypeHandler</code>, 可以不配置.</li><li>如果想要在初始化时, 创建TypeHandler, 有两种方式<ol><li>配置<code>mybatis-plus.type-enums-package</code>. 自动为该包下的所有enum,注册MybatisPlusEnumTypeHandler.</li><li>在model中为枚举字段注解@TableField(typeHandler = xxx), 为该枚举,注册指定的TypeHandler.</li></ol></li><li>如果想要在使用时, 实时创建Typehandler. 枚举实现IEnum接口,或者为想要序列化的字段设置@EnumValue注解.</li></ul><p>所以,使用者只需要为枚举上需要转换的字添加@EnumValue即可, 无需做其他.</p><h3 id=原理>原理</h3><p>启动项目时, 通过typeEnumsPackage配置的包名, 加载指定包下的所有枚举类型, 并将枚举类型注册到mybatis中.</p><ol><li>扫描包下的所有枚举, 且枚举必须继承 IEnum(MybatisPlus提供的枚举接口).</li><li>根据枚举, 生成MybatisEnumTypeHandler实例, 并注册到mybatis中. 每个enum生成一个独有的MybatisEnumTypeHandler实例.</li></ol><p>源码见<code>MybatisSqlSessionFactoryBean.buildSqlSessionFactory()</code></p><h2 id=mybatisplus中枚举处理的另一种方式>mybatisPlus中枚举处理的另一种方式</h2><p>指定enum(或任意javaType)使用jacksonTypeHandler, 使用json对enum序列化. 该方案简单而通用,可以对任意javaType序列化.
缺陷是 json序列化的格式不一定能满足需求.</p><h2 id=延伸>延伸</h2><blockquote><p>问题：如何实现<code>泛型TypeHandler</code>?
答案是<code>无法实现</code>,原因如下:</p></blockquote><ol><li>由于泛型擦除,所以需要为泛型类的所有子类,创建专用的TypeHandler. mybatis的<code>EnumTypeHandler</code> 和mybatis-plus的<code>MybatisEnumTypeHandler</code>是同样的原理, 只是创建的方式不同.</li></ol><ul><li>mybatis是在getTypeHandler时, 为enum实时创建专用TypeHandler.</li><li>mybatis-plus增加了: 初始化时, 通过type-enums-package,为包下的所有Enum创建专用TypeHandler.</li></ul><ol start=2><li>由于mybatis-plus提供了@tableFiled字段,所以在model的字段上, 指定<code>泛型TypeHandler</code>， 这是否可行呢？
该方法不可用。Java的获取泛型参数，只能通过父类的泛型参数来获得。即只有在编译期明确指出的泛型参数，才可以获取到。
见[[java中继承与泛型]]</li></ol></content></article></main><footer></footer></body></html>