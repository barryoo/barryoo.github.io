<!doctype html><html lang=en-US><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://barryoo.github.io/favicon.ico><title>web实时通信技术方案 | Barry Blog</title>
<meta name=title content="web实时通信技术方案"><meta name=description content="http长轮询 通过延长http响应超时时间.使得服务端可以在一定时间内持有该连接. 当有新消息时,再响应.
servelet3支持异步请求。 springmvc对其进行了支持， 使用DeferredResult
SSE server sent event 基于 WebSocket 协议的一种服务器向客户端发送事件和数据的单向通讯 开发简单，和传统的http开发几乎无任何差别,客户端开发简单,有标准支持 单工通信.只能服务器端向客户端发送数据.
webSocket 在应用层的socket连接.基于TCP/IP. 全双工通信
websocket框架 cometd 实现了http长轮询与webSocket. 可根据客户端的支持程度,自动选择合适的通信技术. netty spring
web push 基于浏览器的notificaitonApi实现. 浏览器向服务商订阅, 得到订阅endpoint. 然后将endpoint发送到服务端. 服务端通过endpoint,发送消息到服务商, 服务商推送消息到浏览器. 国内网络无法使用FCM/GCM/firebase.
HTTP/2 HTTP/2的推送技术,只针对静态资源,且必须是编排好的资源. 不能像websocket一样推送. HTTP/2的推送用于提升网页加载速度. 但是由于没有缓存协商, 会导致网络资源浪费."><meta name=keywords content="长连接,websocket,"><meta property="og:title" content="web实时通信技术方案"><meta property="og:description" content="http长轮询 通过延长http响应超时时间.使得服务端可以在一定时间内持有该连接. 当有新消息时,再响应.
servelet3支持异步请求。 springmvc对其进行了支持， 使用DeferredResult
SSE server sent event 基于 WebSocket 协议的一种服务器向客户端发送事件和数据的单向通讯 开发简单，和传统的http开发几乎无任何差别,客户端开发简单,有标准支持 单工通信.只能服务器端向客户端发送数据.
webSocket 在应用层的socket连接.基于TCP/IP. 全双工通信
websocket框架 cometd 实现了http长轮询与webSocket. 可根据客户端的支持程度,自动选择合适的通信技术. netty spring
web push 基于浏览器的notificaitonApi实现. 浏览器向服务商订阅, 得到订阅endpoint. 然后将endpoint发送到服务端. 服务端通过endpoint,发送消息到服务商, 服务商推送消息到浏览器. 国内网络无法使用FCM/GCM/firebase.
HTTP/2 HTTP/2的推送技术,只针对静态资源,且必须是编排好的资源. 不能像websocket一样推送. HTTP/2的推送用于提升网页加载速度. 但是由于没有缓存协商, 会导致网络资源浪费."><meta property="og:type" content="article"><meta property="og:url" content="https://barryoo.github.io/web%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/"><meta property="og:image" content="https://barryoo.github.io/images/share.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2018-03-13T00:00:00+00:00"><meta property="article:modified_time" content="2018-03-13T00:00:00+00:00"><meta property="og:site_name" content="barry blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://barryoo.github.io/images/share.png"><meta name=twitter:title content="web实时通信技术方案"><meta name=twitter:description content="http长轮询 通过延长http响应超时时间.使得服务端可以在一定时间内持有该连接. 当有新消息时,再响应.
servelet3支持异步请求。 springmvc对其进行了支持， 使用DeferredResult
SSE server sent event 基于 WebSocket 协议的一种服务器向客户端发送事件和数据的单向通讯 开发简单，和传统的http开发几乎无任何差别,客户端开发简单,有标准支持 单工通信.只能服务器端向客户端发送数据.
webSocket 在应用层的socket连接.基于TCP/IP. 全双工通信
websocket框架 cometd 实现了http长轮询与webSocket. 可根据客户端的支持程度,自动选择合适的通信技术. netty spring
web push 基于浏览器的notificaitonApi实现. 浏览器向服务商订阅, 得到订阅endpoint. 然后将endpoint发送到服务端. 服务端通过endpoint,发送消息到服务商, 服务商推送消息到浏览器. 国内网络无法使用FCM/GCM/firebase.
HTTP/2 HTTP/2的推送技术,只针对静态资源,且必须是编排好的资源. 不能像websocket一样推送. HTTP/2的推送用于提升网页加载速度. 但是由于没有缓存协商, 会导致网络资源浪费."><meta itemprop=name content="web实时通信技术方案"><meta itemprop=description content="http长轮询 通过延长http响应超时时间.使得服务端可以在一定时间内持有该连接. 当有新消息时,再响应.
servelet3支持异步请求。 springmvc对其进行了支持， 使用DeferredResult
SSE server sent event 基于 WebSocket 协议的一种服务器向客户端发送事件和数据的单向通讯 开发简单，和传统的http开发几乎无任何差别,客户端开发简单,有标准支持 单工通信.只能服务器端向客户端发送数据.
webSocket 在应用层的socket连接.基于TCP/IP. 全双工通信
websocket框架 cometd 实现了http长轮询与webSocket. 可根据客户端的支持程度,自动选择合适的通信技术. netty spring
web push 基于浏览器的notificaitonApi实现. 浏览器向服务商订阅, 得到订阅endpoint. 然后将endpoint发送到服务端. 服务端通过endpoint,发送消息到服务商, 服务商推送消息到浏览器. 国内网络无法使用FCM/GCM/firebase.
HTTP/2 HTTP/2的推送技术,只针对静态资源,且必须是编排好的资源. 不能像websocket一样推送. HTTP/2的推送用于提升网页加载速度. 但是由于没有缓存协商, 会导致网络资源浪费."><meta itemprop=datePublished content="2018-03-13T00:00:00+00:00"><meta itemprop=dateModified content="2018-03-13T00:00:00+00:00"><meta itemprop=wordCount content="39"><meta itemprop=image content="https://barryoo.github.io/images/share.png"><meta itemprop=keywords content="长连接,websocket,"><meta name=referrer content="no-referrer-when-downgrade"><style>html{scroll-behavior:smooth}body{font-family:Verdana,sans-serif;margin:auto;padding:20px;text-align:left;background-color:#fff;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:#444}header{margin:auto;text-align:center;max-width:720px}.menu{justify-content:space-between;display:flex}main{margin:0 auto}.blog-posts-container{width:fit-content;margin:auto}.tag-container{max-width:720px}h1,h2,h3,h4,h5,h6,strong,b{color:#222}a{color:#3273dc}.title{text-decoration:none;border:0;text-align:center;color:#000;font-size:25px}.title span{font-weight:400}nav a{margin-right:10px}textarea{width:100%;font-size:16px}input{font-size:16px}.toc{max-width:250px;width:auto;top:20%;position:fixed;font-size:13px}.toc a{color:rgba(128,128,128,.4);text-decoration:none;display:block}.toc a:hover{color:#777}article{max-width:1080px;margin:0 auto;margin-left:calc(max((100% - 1080px)/2,250px))}content{line-height:1.6}table{width:100%}img{max-width:100%}code{padding:2px 5px;background-color:#f2f2f2}pre code{color:#222;display:block;padding:20px;white-space:pre-wrap;font-size:14px;overflow-x:auto}div.highlight pre{background-color:initial;color:initial}div.highlight code{background-color:unset;color:unset}blockquote{border-left:1px solid #999;color:#222;padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.helptext{color:#777;font-size:small}.errorlist{color:#eba613;font-size:small}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li span{margin-right:30px}ul.blog-posts li a:visited{color:#8b6fcb}@media(prefers-color-scheme:dark){body{background-color:#333;color:#ddd}h1,h2,h3,h4,h5,h6,strong,b{color:#eee}a{color:#8cc2dd}code{background-color:#777}pre code{color:#ddd}blockquote{color:#ccc}textarea,input{background-color:#252525;color:#ddd}.helptext{color:#aaa}}@media only screen and (max-width:1020px){.toc{width:auto;position:relative}article{padding-left:0;margin:0 auto}}</style></head><body><header><nav class=menu><a id=siteTitle href=/ class=title>Barry Blog</a><div style=display:flex><a href=/>Home</a>
<a href=https://github.com/barryOO>github</a>
<a href=/blog/>Blog</a></div></nav></header><main><aside class=toc><a href=#siteTitle style=margin-left:40px>top</a><nav id=TableOfContents><ul><li><a href=#http长轮询>http长轮询</a></li><li><a href=#sse-server-sent-event>SSE server sent event</a></li><li><a href=#websocket>webSocket</a><ul><li><a href=#websocket框架>websocket框架</a></li></ul></li><li><a href=#web-push>web push</a></li><li><a href=#http2>HTTP/2</a></li></ul></nav></aside><article><h1 style=font-size:40px>web实时通信技术方案</h1><p><i><time datetime=2018-03-13 pubdate>13 Mar, 2018</time></i></p><p><a href=https://barryoo.github.io/blog/%E9%95%BF%E8%BF%9E%E6%8E%A5/>#长连接</a>
<a href=https://barryoo.github.io/blog/websocket/>#websocket</a></p><content><h2 id=http长轮询>http长轮询</h2><p>通过延长http响应超时时间.使得服务端可以在一定时间内持有该连接. 当有新消息时,再响应.</p><p>servelet3支持异步请求。 springmvc对其进行了支持， 使用<code>DeferredResult</code></p><h2 id=sse-server-sent-event>SSE server sent event</h2><p>基于 WebSocket 协议的一种服务器向客户端发送事件和数据的单向通讯
开发简单，和传统的http开发几乎无任何差别,客户端开发简单,有标准支持
单工通信.只能服务器端向客户端发送数据.</p><h2 id=websocket>webSocket</h2><p>在应用层的socket连接.基于TCP/IP. 全双工通信</p><h3 id=websocket框架>websocket框架</h3><p>cometd 实现了http长轮询与webSocket. 可根据客户端的支持程度,自动选择合适的通信技术.
netty
spring</p><h2 id=web-push>web push</h2><p>基于浏览器的notificaitonApi实现.
浏览器向服务商订阅, 得到订阅endpoint. 然后将endpoint发送到服务端.
服务端通过endpoint,发送消息到服务商, 服务商推送消息到浏览器.
国内网络无法使用FCM/GCM/firebase.</p><h2 id=http2>HTTP/2</h2><p>HTTP/2的推送技术,只针对静态资源,且必须是编排好的资源. 不能像websocket一样推送.
HTTP/2的推送用于提升网页加载速度. 但是由于没有缓存协商, 会导致网络资源浪费.</p></content></article></main><footer></footer></body></html>