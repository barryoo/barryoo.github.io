<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blog on Barry Blog</title><link>https://barryoo.github.io/blog/</link><description>Recent content in Blog on Barry Blog</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><copyright>Copyright © 2023, Barry Chen.</copyright><lastBuildDate>Thu, 11 May 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://barryoo.github.io/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>graphQL应用场景分析</title><link>https://barryoo.github.io/graphql%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/</link><pubDate>Thu, 11 May 2023 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/graphql%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF%E5%88%86%E6%9E%90/</guid><description>参考 https://www.pupboss.com/post/2021/experience-sharing-of-graphql-backend/
graphQL GraphQL要解决的问题: 优化客户端向服务器请求数据的过程.
对于同样的业务需求, REST API可能要请求多个endpoints, GraphQL可以用一个请求. 数据形式是客户端定义的, 只取想要的数据, 不会取多余的数据, 减小了数据传输量. 各个前端可以访问自己想要的数据. 快速开发, feature快速迭代. 升级改动时, 可能不需要后端改动. 优点 避免请求冗余和数据冗余 可以提升开发效率,可以提升性能. 减少前端请求次数(事实上我不知道这有什么意义)
文档维护方便
开发效率
适合微服务 通过定义schema,自动从各个微服务中获取数据.
缺点 迁移成本 debug和test麻烦. graphql侵入性大, 耦合性高. 现有系统迁移成本很高. 只有一个URI,所以权限控制/限流/网关/等等与URI相关的功能,都要重新实现. 对URI的颠覆式使用,让graphql的使用成本也是颠覆式的.
性能 通过&amp;quot;最大查询深度、查询复杂度加权、避免递归或持久查询&amp;quot;来避免性能问题. 但graphql性能优化很难, 一个接口应对多种场景. 而restful一个接口对应一个场景,可以针对性的优化. 系统的瓶颈往往在数据库. 通过graphql可以减少前端请求次数,只是稍微方便了前端开发, 却带来了问题. 大部分时候,我们是希望通过异步加载来优化性能的.
前端自由查询,复杂度转移给了后端, 但后端难以对查询进行优化, 查询深度限制只是限制最低标准, 并不是最优, 如果前端导出都卡着这个限制来查询, 数据库压力会很大, 数据库压力大, 也就意味着成本的增加. 后端开发者应该对数据库性能负责, 但是graphql导致后端开发者无法全力负责, 这是矛盾的. 数据库的优化是要自始至终 细小甚微的.
缓存优化困难.
主要的技术栈是nodejs, 其他语言支持度不高.
限流 在 REST API 中，你可以简单地指定我们一天只允许这个数量的请求，但在 GraphQL 中，很难指定这种类型的语句。
总结 我只是想让接口提供的字段更灵活, 但是graphql让我重写整个架构. 解决了一个小问题, 却带来了更大的问题.</description></item><item><title>Clash分流规则实践</title><link>https://barryoo.github.io/clash%E5%88%86%E6%B5%81%E8%A7%84%E5%88%99%E5%AE%9E%E8%B7%B5/</link><pubDate>Sat, 06 May 2023 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/clash%E5%88%86%E6%B5%81%E8%A7%84%E5%88%99%E5%AE%9E%E8%B7%B5/</guid><description>参考 https://github.com/Kuingsmile/clash-core/blob/main/docs/premium/rule-providers.md#rule-providers
目标 实现clash配置分流规则, 以及快速修改规则.
为什么要使用clash来控制分流规则? 我们确实可以通过浏览器扩展SwitchyOmega, 在浏览器中修改当前网站的代理, 但只能实现一个代理, 无法实现不同的网站走不同的代理. 通过clash分流,可以实现以下效果:
youtube.com 走香港代理,延迟低. openai.com 走英国代理,防止被屏蔽. 如何快速修改规则 在SwitchyOmega中, 可以快速修改浏览器的代理规则, 但是没有一种浏览器扩展可以与clash通信,来修改规则. 这里提供shell命令的方式来修改, 比修改config.yaml文件要方便些. 期待有人可以开发浏览器扩展与clash通信. shell命令可以与alfred等快速启动软件结合, 进而实现更方便的方式. 也可以在alfred中创建workflow来修改规则.
# 添加openai.com走ai代理 proxy -y &amp;#34;DOMAIN,openai.com,ai&amp;#34; # 删除google.com走proxies代理 proxy -n &amp;#34;DOMAIN,google.com,proxies&amp;#34; proxy命令的代码如下,使用方法:
复制以下代码, 在你的环境变量目录下新建文件名为proxy,并粘贴一下代码,保存. (环境变量目录如: /usr/local/bin) terminal中执行chmod +x proxy 重启terminal #!/bin/bash CONFIG_FILE=&amp;#34;$HOME/.config/clash/config.yaml&amp;#34; PORT=9090; while getopts &amp;#34;y:n:&amp;#34; opt; do case ${opt} in y ) # Add a new rule if [ -z &amp;#34;$2&amp;#34; ]; then echo &amp;#34;Please provide a rule with the -y option.</description></item><item><title>springBoot配置加载顺序</title><link>https://barryoo.github.io/springboot%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</link><pubDate>Fri, 10 Mar 2023 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/springboot%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</guid><description>参考 https://docs.spring.io/spring-boot/docs/2.3.9.RELEASE/reference/htmlsingle/#boot-features-external-config https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config spring2.0与3.0版本的加载顺序不一致, 差异在于config data file的加载顺序不同.
注意: 请以springboot启动流程中配置文件的加载顺序,后加载覆盖先加载来考虑,而不是配置的优先级来考虑. 这样会得到更准确的结果, 也更符合直觉.
PropertySource顺序 加载顺序如下, 下面的覆盖上面的.
Default properties (specified by setting SpringApplication.setDefaultProperties).
@PropertySource annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins.
Config data (such as application.properties files).</description></item><item><title>async与await</title><link>https://barryoo.github.io/async%E4%B8%8Eawait/</link><pubDate>Sun, 19 Jun 2022 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/async%E4%B8%8Eawait/</guid><description>async/await是一种新的语法，用同步的编程方式替换原有的回调函数和协程的用法.
.net中的async await async async 用于修饰方法, 方法的返回值必须是 void或者Task&amp;lt;T&amp;gt;. async的目的是:使方法内的await关键字生效。
await await 仅可用于由 async 关键字修饰的异步方法中。如果没有async会报错. await修饰的方法, 返回值必须是Task. 如果要对普通调用使用await, 可以使用Task.Run(()=&amp;gt;{ method() })把方法包装成一个返回值为Task的匿名函数.
代码执行到await 标记的异步方法时, 主方法立即return, 之后的代码被阻塞,一直到异步方法完成,才会执行. 所以await, 相当于为本方法中 await之后的所有代码添加一个异步回调的任务.
async修饰的方法, 被调用时,
不加await, 异步方法是异步执行, 异步方法后面的代码在当前线程中同步执行. 加await, 异步方法是同步执行. 总结 异步可以提高响应能力。 异步不会阻塞线程 使用 async 来标记异步方法 使用 await 来指定暂停点，挂起其进度，在等待的异步过程完成后才能继续通过该点。同时，会将控制权返回至异步方法的调用方，调用方可以继续执行不依赖于异步返回结果的其它工作。 如果使用了 Async 最好一直使用它 异步方法避免使用 Task.Wait 和 Task.Result ，因为他们会导致死锁。
javascript中的async await async async 函数返回的是一个 Promise 对象. await 只能出现在 async 函数中 如果在函数中 return 一个直接量，async 会把这个直接量通过 Promise.resolve() 封装成 Promise 对象。 如果 async 函数没有返回值， 它会返回 Promise.</description></item><item><title>Serverless简单介绍</title><link>https://barryoo.github.io/serverless%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/serverless%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</guid><description>serverless分为FASS BASS PASS 不是不需要服务器, 而是不需要管理服务器.
核心价值 简化运维 弹性伸缩 按需付费
特点 按需加载 事件驱动 应用无状态 自动弹性伸缩 BASS backend as a service 后端即服务 BaaS提供应用依赖的第三方服务, 如数据库, 缓存, 消息队列, 文件存储, 身份认证, 分析, 云函数等, 通常有云服务商提供, 或者第三方提供. 与PaaS的区别是,PaaS需要使用者管理服务的生命周期, 而BasS只需要使用服务.
FASS function as a server 例如:AWS Lambda，Google Cloud Functions，Azure Functions, alyun FC
面临的问题 难以移植，与云服务商绑定 通常serverless是云服务商提供的, 云服务商的serverless产品不兼容. 服务商提供一系列可供快速使用产品作为服务, 接口通常是专有的,不会与其他服务商兼容. 好在，现在有开源的serverless平台, 各云服务商都可使用。或者使用自定义的container运行时,也可以减少对云服务商的依赖. 缺少控制力 由于用户只需关注代码，也意味着用户无法控制运行的底层环境。 除了代码之外的一切，都发生了质变，意味着工作流程的巨大变化。事实上，代码也变了，如果使用专有的serverless框架，那么对于事件的处理方式，与原方式不同。 调试，测试，应用监控，日志，中间件都与以往不同。 serverless框架 serverless devs 阿里云开源, 支持多云, 支持多语言, 支持多平台, 支持多种运行时. serverless framework AWS Lambda，最早被大众所认可的 Serverless 实现。 Azure Functions，来自微软公有云的 Serverless 实现。 OpenWhisk，Apache 社区的开源 Serverless 框架。 Kubeless，基于 Kubernetes 架构实现的开源 Serverless 框架。 Fission，Platform9 推出的开源 Serverless 框架。 OpenFaaS，以容器技术为核心的开源 Serverless 框架。 Fn，来自 Oracle 的开源 Serverless 框架，由原 Iron Functions 团队开发 FASS详解 概念 服务</description></item><item><title>springBoot打包容器镜像的多种方式实践</title><link>https://barryoo.github.io/springboot%E6%89%93%E5%8C%85%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E8%B7%B5/</link><pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/springboot%E6%89%93%E5%8C%85%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E8%B7%B5/</guid><description>方式一. maven docker各自运作 使用maven打包为可执行jar包. 编写Dockerfile, 复制jar, 运行jar包. 方式二. maven docker各自运行, 手动分层 使用maven打包为可执行jar包. 解压缩jar包, 并放置到不同层目录中. mkdir -p target/dependency &amp;amp;&amp;amp; (cd target/dependency; jar -xf ../*.jar) 编写Dockerfile, 复制各层的文件, 运行main方法. FROM beevelop/java:latest COPY target/dependency/BOOT-INF/lib /app/lib COPY target/dependency/META-INF /app/META-INF COPY target/dependency/BOOT-INF/classes /app ENTRYPOINT [&amp;#34;java&amp;#34;,&amp;#34;-cp&amp;#34;,&amp;#34;app:app/lib/*&amp;#34;,&amp;#34;com.example.springbootdocker.SpringBootDockerApplication&amp;#34;] 方式三. 在maven执行打包容器镜像. pom.xml中配置容器参数 执行mvn spring-boot:build-image打包. 如果配置了registry, 会自动push 可在pom.xml中配置容器参数. 可在mvn 命令中传入容器参数. docker运行时, 可以通过-e传递springboot运行参数.例如: docker run -e &amp;quot;SPRING_PROFILES_ACTIVE=prod&amp;quot; -p 8080:8080 -t springio/gs-spring-boot-docker
方式四. 在maven执行打包容器镜像, 自动分层. 在spring-boot-maven-plugin中配置layers参数. 本质上只是打包时,添加了一个layers.idx文件.
&amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;layers&amp;gt; &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt; &amp;lt;/layers&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; 实践建议 spring-boot的spring-boot-maven-plugin使用了buildpacker来进行构建镜像, 无需做任何配置, 是最简单的方式, 但是由于国内网络,导致buildpacker相关组件无法下载, 所以该方式不能正常使用.</description></item><item><title>docker构建加速</title><link>https://barryoo.github.io/docker%E6%9E%84%E5%BB%BA%E5%8A%A0%E9%80%9F/</link><pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/docker%E6%9E%84%E5%BB%BA%E5%8A%A0%E9%80%9F/</guid><description>https://docs.docker.com/build/cache/
https://juejin.cn/post/7022957854889869325
尽量使用缓存,优先执行没有文件变动的命令,让可缓存的命令在底层.
目标 保持构建环境一致. 最好的方式是使用dockerFile进行构建, 保证jdk和maven版本完全一致. 加速maven打包,以及dockerFile build的速度. maven构建加速 方式1. 提前解决依赖, 则COPY源码进行build copy pom.xml first, executemvn dependency:go-offline, resolve all dependencies, this layer will be cached as long as pom.xml not changed. then copy source code, execute mvn package 在多模块项目中, 可以按照目录结构把父模块和子模块的pom.xml分开COPY, 然后执行mvn dependency:go-offline. 该方案的问题在于:
如果pom.xml文件有变更, 则会导致所有依赖都重新下载, 无法利用缓存. 私仓配置动态传入 方式2. 对构建过程中的依赖进行缓存挂载 RUN --mount=type=cache,target=/root/.m2 mvn clean package -Dmaven.test.skip=true 该样例中对/root/.m2目录进行缓存挂载. 第一次构建时较慢, 因为需要下载所有依赖, 后续构建就会很快, 即使pom.xml文件有变更, 也只会下载变更的依赖.
该方案的问题在于
第一次构建需要下载所有依赖. 私仓配置无法动态传入. 如果需要配置私仓, 则需要自己构建base image, 并在base image中配置私仓, 然后使用该image作为build的基础镜像.</description></item><item><title>MacOS输入法切换最佳实践</title><link>https://barryoo.github.io/macos%E8%BE%93%E5%85%A5%E6%B3%95%E5%88%87%E6%8D%A2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</link><pubDate>Tue, 30 Nov 2021 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/macos%E8%BE%93%E5%85%A5%E6%B3%95%E5%88%87%E6%8D%A2%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/</guid><description>快速切换中英文输入法 写代码时, 经常要在中英文输入之间切换, 为了提高效率, 就想要实现一键切换输入法.经过尝试, 发现使用Control切换输入法效率最高. 自带的输入法可以通过caps lock切换, 但需要移动左手, 并且该输入法的词库太差. 使用Shift切换, 会导致在使用Shift输入大写字母时,有一定概率导致输入法切换. 而使用Control,不需要移动手,直接使用手掌根部按压即可.
如何实现Control切换输入法. 直接上结论: chrome浏览器在密码框中,会自动修改输入法为系统自带输入法.所以方案3是最完美的方案.
方案1 安装软件`ishud``. 可以指定 left control/ left option/ left command/right control/right option/right command 一键切换. 同时还可以在屏幕中间显示当前的输入法.
该方案简单,而且几乎完美.唯一的问题是,有些键盘对mac的兼容性不太好, 导致在两个不同键盘间切换时, 切换输入法的按键会变动.
另外, 该软件已经多年没有更新.
方案2 使用一些键位定制工具,如karabiner. 该方案太重, 如果没有其他更换键位的需求, 不建议该方案.
方案3 搜狗输入法支持使用Control切换中英文.所以需要删除MacOS自带的输入法,仅保留搜狗输入法.
在~/Library/Preferences/com.apple.HIToolbox.plist文件中AppleEnabledInputSources, 删除KeyboardLayout Name U.S.
看似简单, 然而操作中会遇到以下问题.
由于plist文件不是纯文本的, 所以不能直接用文本编辑器打开, 需要转换. 打开terminal软件, 执行命令plutil -convert xml1 ~/Library/Preferences/com.apple.HIToolbox.plist MacOS会自动检测该文件,如果被修改, 则会自动还原. 所以需要使用文件锁点功能, 文件-&amp;gt;右键-&amp;gt;查看简介-&amp;gt;锁定文件. 具体操作如下: 执行上面的shell命令,立即锁定文件. 使用文本剪辑器打开文件, 修改, 先不保存. 解锁文件,立即保存文件,再立即锁定. 重新打开文件, 查看文件内容, 确认文件是否被修改成功.</description></item><item><title>投屏相关技术</title><link>https://barryoo.github.io/%E6%8A%95%E5%B1%8F%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/</link><pubDate>Mon, 06 Sep 2021 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/%E6%8A%95%E5%B1%8F%E7%9B%B8%E5%85%B3%E6%8A%80%E6%9C%AF/</guid><description>DLNA DLNA: 基于有线网络或者无线网络, 支持IPv4/v6, 只能使用http协议. DLNA基于本质上是把播放地址传给其他设备, 所以只能播放多媒体资源. 只需要软件实现, 不需要硬件支持. 有版权的视频,需要视频软件自己实现, 为了避免视频盗版, 投屏时,会生成授权. 看墙外的视频,会有障碍.
miracast 基于WiFi Direct的显示镜像技术. 且只能基于WIFI, 不支持有线网络, 设备间直连, 不需要接入WIFI局域网, 不需要路由器. 可以对UI层管理, 并非所有的UI层都会传输. android原生自带miracast, 但是android10之后原生不再自带miracast, 换成了chromecast. 在不同的设备中, 你会看到不同的命名: 如Wlan display、Wifi display、Miracast、Allshare cast、Mirroring screen、无线显示 台式主机想要使用miracast, 必须使用支持miracast的无线网卡.
Chromecast chromecast是google开发的类似miracast的镜像显示技术. 可以把手机或电脑的浏览器标签页镜像到电视. 电视接收端需要专有硬件支持. google推出了chromecast电视棒, NVIDIA 与google合作推出了nvidia shield tv, SONY电视内置了chromecast. 其他也有三方软件模拟chromecast, 但不是合法的.
airplay Apple独有协议. 支持从IOS或Mac投屏到appleTV, 但是不支持IOS投屏到Mac. 2021年6月, apple升级airplay, 支持IOS投屏到Mac
airplay支持类似DLNA的媒体传输, 也支持类似miracast的镜像. 甚至支持多屏协作, 可以把其他设备作为第二显示器. 例如macbook可以把ipad作为第二显示器.
airplay由apply严格管理, 哪些设备可以在什么场景下投向哪些设备, 而不是像其他投屏协议, 定义好客户端与接收端, 就可以任意投屏. 例如mac可以投屏到ipad, 但是ios不可以.
三方软件airserver, 逆向airPlay协议, 实现了airplay接收端. 只需要在mac上安装接收端软件, iphone/ipad就可以投屏到mac, iphone/ipad不需要安装额外的软件.</description></item><item><title>mybatis TypeHandler原理分析与思考</title><link>https://barryoo.github.io/mybatis-typehandler%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83/</link><pubDate>Mon, 30 Nov 2020 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/mybatis-typehandler%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%E4%B8%8E%E6%80%9D%E8%80%83/</guid><description>TypeHandler使用 在自定义TypeHandler上注解@MappedTypes(value = {A.class, B.class}) 配置typeHandlersPackage. 包下的所有TypeHandler都会被自动注册. Mapper.xml中声明&amp;lt;result column=&amp;quot;enum1&amp;quot; jdbcType=&amp;quot;INTEGER&amp;quot; typeHandler=&amp;quot;xxx&amp;quot;/&amp;gt; mybatis配置文件 &amp;lt;typeHandlers&amp;gt; &amp;lt;typeHandler handler=&amp;#34;com.xxx.handler.EnumTypeHandler&amp;#34;/&amp;gt; &amp;lt;/typeHandlers&amp;gt; TypeHandler工作原理 自动注册JavaType的所有默认TypeHandler. 见TypeHandlerRegistry 虽然Enum不是JavaType, 但是会自动设置默认的EnumTypeHandler. 在根据javaType获取TypeHandler的时候, 会判断class是否是enum, 如果是, 则会生成该enum专用的EnumTypeHandler TypeHandler注册时,需要寻找对应的JavaType. 如果已经指定JavaType, 则直接可以注册 如果没有指定, 则尝试通过@MappedTypes注解, 找到JavaType 如果依然找不到JavaType, 则判断该TypeHandler是否继承TypeReference&amp;lt;T&amp;gt;,通过getSuperclassTypeParameter方法,可以得到泛型的JavaType. 如果依然找不到JavaType, 则JavaType为null,进行注册. preparedStatement设值时, 调用来字段对应的HandlerType,进行转换. 查询数据库结果后, 调用字段对应的HandlerType.setResult. mybatis中对于Enum的类型处理 使用者什么都不用做, 自动支持.
mybatis提供了EnumTypeHandler和EnumOrdinalTypeHandler.
EnumTypeHandler: 调用Enum.name()方法, 将枚举转换为String. EnumOrdinalTypeHandler: 调用Enum.ordinal()方法, 将枚举转换为int. 当需要转换枚举类型时, 优先使用缓存中的TypeHandler, 如果没有找到, 则实时生成专用的EnumTypeHandler.
MybatisPlusEnumTypeHandler MybatisPlus通过MybaitsEnumTypeHandler增强对enum的支持,允许指定转换时使用的字段.
使用 配置mybatis-plus.defaultEnumTypeHandler, 默认是org.apache.ibatis.type.EnumTypeHandler, 可以不配置. 如果想要在初始化时, 创建TypeHandler, 有两种方式 配置mybatis-plus.type-enums-package. 自动为该包下的所有enum,注册MybatisPlusEnumTypeHandler. 在model中为枚举字段注解@TableField(typeHandler = xxx), 为该枚举,注册指定的TypeHandler. 如果想要在使用时, 实时创建Typehandler. 枚举实现IEnum接口,或者为想要序列化的字段设置@EnumValue注解.</description></item><item><title>Java多项目依赖管理</title><link>https://barryoo.github.io/java%E5%A4%9A%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</link><pubDate>Sat, 06 Jun 2020 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/java%E5%A4%9A%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96%E7%AE%A1%E7%90%86/</guid><description>maven依赖继承与聚合 见官方文档
spring的依赖管理 以spring-cloud为例进行说明
spring-cloud-dependencies Hoxton.SR6 定义spring-cloud中各个组件的版本. 组件的版本各不一致. 用于规定各组件之间的版本兼容性.
组件内 组件以及组件的子模块的版本完全统一, 有任何改动都会导致整个组件的版本递增. 也会定义组件的外部依赖的版本号, 对其统一管理.
我使用的依赖管理 与spring的依赖管理类似, 也有不同之处.
每个组件的外部依赖版本, 不是在组件内定义, 而是由base-pom统一定义. 这样做的好处是,由于组件之间存在依赖,且组件的外部依赖可能冲突,为了避免冲突,外部依赖的版本统一管理.
版本升级策略 版本号 大版本.小版本.修复版本 大版本:当组件出现重大迭代,会增加大版本号. 小版本:当组件新增feature,会增加小版本号. 修复版本:当修复缺陷,会增加修复版本号.
升级策略
定义新的开发版本, 如1.23.45-SNAPSHOT. 版本应用到组件内所有模块, 并提交代码. 修改代码,并提交代码. 代码通过测试,可以发布时, 修改版本为release. 如1.23.45. 版本应用到组件内所有模块. 并提交代码. 发布组件 定义新的开发版本, 如1.23.46-SNAPSHOT 或 1.24.0-SNAPSHOT 题外:微服务中monoRepo与multiRepo如何选择. monorepo: 单一代码库,所有项目都在这一个代码库中. multiRepo: 多代码库, 每个项目一个代码库.
首先明确一点,无论团队大小, 既然是微服务, 那肯定会为每个服务指定负责人, 而不会交错负责.
multiRepo优点:
每个人只需要关注自己负责的服务的代码. 小团队,可以避免团队内有人随意修改他人负责的代码. 大团队,只开负责的代码仓库的权限. IDEA 中只打开自己负责的代码, 搜索代码什么的都很方便. CI/CD 方便 版本管理方便, 减少代码冲突. multiRepo缺点:
需要搭建 maven 私仓, 对所有的公共技术模块进行严格的版本管理, 在 base-pom 中对版本进行统一管理.</description></item><item><title>字符编码</title><link>https://barryoo.github.io/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</link><pubDate>Sat, 23 Nov 2019 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</guid><description>字符编码 简介 unicode包含了世界上所有的字符。 gb2123只有中文字符，GBK是它的升级版。 UTF8 UTF-16 UTF-24是Unicode的实现方式（或者传输方式|存储方式）。 浏览器的URL编码是UTF-8，url中的参数编码是跟随系统编码，通常也是UTF-8。例如&amp;quot;q=%E6%98%A5%E8%8A%82&amp;quot;，是字符的UTF8编码，每个字符前面加上“%”。 在javascript中，escape()得到的是unicode编码。encodeURI()方法得到的是utf-8编码。 URL只支持ASCII编码，所以URL中的字符必须编码。
URL编码 URL中不支持特殊符号，也为了防止=&amp;amp;这样的符号造成奇异，需要为query键值对进行编码。 URL中只允许存在字母数字和-_.~这4个符号，还有一些保留字符。
! * ' ( ) ; : @ &amp;amp; = + $ , / ? # [ ] URL只支持ASCII编码，所以URL中的字符必须编码。 标准ASCII编码有128个字符。 对于Unicode字符，RFC文档建议使用utf-8对其进行编码得到相应的字节，然后对每个字节执行百分号编码。关于encodeURI使用的还是UTF-8，并不会受到页面字符集的影响。 安全字符不需要被编码。编码要做的是把不安全字符用安全字符表示；另外，当安全字符作为值出现时，也需要编码。
js提供了3中编码的方式。
escape（69个）：*/@+-._0-9a-zA-Z encodeURI（82个）：!#$&amp;amp;&amp;rsquo;()*+,/:;=?@-._~0-9a-zA-Z encodeURIComponent（71个）：!&amp;rsquo;()*-._~0-9a-zA-Z 通常使用第2个和第3个。 encodeURI用于整个URI的编码。它的安全字符更多，可以使用;#&amp;amp;$这样的字符； encodeURIComponent用于URI中单个组件的编码。他的安全字符较少。例如对query中的value进行编码，如果value中包含了&amp;quot;&amp;amp;&amp;quot;,那么&amp;quot;&amp;amp;&amp;ldquo;就会变编码。
ISO-8859-1 单字节编码，兼容ASCII，是JAVA网络传输使用的标准字符集
urlEncode原理 url只能显示ascii支持的字符. 为了显示其他非ascii字符, 需要根据unicode字符集, 使用某一种编码方式(如UTF-8) 对字符进行编码, 并在编码结果的每个十六进制数字前面加上%.
如: 汉字&amp;#34;中&amp;#34; 在unicode中的顺序为20013 10进制 20013 十六进制 4 e 2 d 二进制 0100 1110 0010 1101 utf8模版 1110XXXX 10XXXXXX 10XXXXXX utf8分割 0100 111000 101101 utf8编码 11100100 10111000 10101101 utf8 16进制 e4 b8 ad 结果 %e4%b8%ad 注意:在互联网上的大部分&amp;quot;在线utf8转中文&amp;quot;的工具, 给出的不是utf8编码, 而是unicode编码的16进制.</description></item><item><title>如何使用Maven运行Java程序</title><link>https://barryoo.github.io/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8maven%E8%BF%90%E8%A1%8Cjava%E7%A8%8B%E5%BA%8F/</link><pubDate>Tue, 06 Aug 2019 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8maven%E8%BF%90%E8%A1%8Cjava%E7%A8%8B%E5%BA%8F/</guid><description>目标 在不依赖任何IDE的情况下, 如何使用maven运行java程序.
IDE做了什么 我们再使用IDEA开发时, 直接点击Run按钮,就可以运行.
这是IDEA 点击RUN按钮后执行的命令, 通过参数指定每个位于maven repository中的jar包的路径, 以及项目中的类路径, 然后执行main方法. 在IDEA中点击RUN/DEBUG, 做的事情如下
使用java 命令执行 命令中指定要运行的main方法的所在的class 命令中通过-classpath指定所有依赖的路径 对于三方依赖,指定其在.m2/repository中的路径 对于本项目中的lib模块,指定其编译后在target目录的位置 你可以自己本地运行下,看看控制台输出的命令是什么.
/Library/Java/JavaVirtualMachines/jdk8.0.332/bin/java -Dmaven.multiModuleProjectDirectory=/Users/chen/workspace/system-controller -Dmaven.home=/Applications/IntelliJ IDEA.app/Contents/plugins/maven/lib/maven3 -Dclassworlds.conf=/Applications/IntelliJ IDEA.app/Contents/plugins/maven/lib/maven3/bin/m2.conf -Dmaven.ext.class.path=/Applications/IntelliJ IDEA.app/Contents/plugins/maven/lib/maven-event-listener.jar -javaagent:/Applications/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=58771:/Applications/IntelliJ IDEA.app/Contents/bin -Dfile.encoding=UTF-8 -classpath /Applications/IntelliJ IDEA.app/Contents/plugins/maven/lib/maven3/boot/plexus-classworlds.license:/Applications/IntelliJ IDEA.app/Contents/plugins/maven/lib/maven3/boot/plexus-classworlds-2.6.0.jar org.codehaus.classworlds.Launcher com.example.App Maven是否可以直接运行java程序 maven的mvn test可以直接执行test代码, 但是maven没有maven run命令来直接执行main方法. 借助exec-maven-plugin插件, 可以通过mvn exec来执行main方法.
如何使用maven直接运行java程序 按照以下命令, 就可以直接运行代码.
mvn clean compile mvn exec:java -Dexec.mainClass=&amp;#34;cpoo.win.DrinkDemo&amp;#34; spring-boot中也可以这样执行. 在多模块项目中,如果要运行的模块依赖了其他模块,需要把其他模块install,否则找不到依赖.
mvn clean compile mvn exec:java -pl system-controller -Dexec.mainClass=&amp;#34;com.bizmatics.system.Application&amp;#34; -pl：指定打包的模块，可以用路径也可以用坐标，如果父项目同时是父目录，那么进入父目录下，直接“-pl 项目目录名”即可</description></item><item><title>连接保活</title><link>https://barryoo.github.io/%E8%BF%9E%E6%8E%A5%E4%BF%9D%E6%B4%BB/</link><pubDate>Tue, 09 Apr 2019 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/%E8%BF%9E%E6%8E%A5%E4%BF%9D%E6%B4%BB/</guid><description>链路可用性检测 TCP连接是虚拟的. 两个状态机同时维护满足逻辑上认为是连接的状态,我们称之为连接. socket连接 是通过双方分别对IP和Port进行监听, 而实现的实时通信. 所以socket对连接是否畅通是无感知的. 如果网络没有问题, 则连接永远存在,不会断开. 当网络不稳定时,双方需要知道对方是否还在,则需要通过发送消息/ACK,来确认.所以心跳是为了确认连接是否还在.
Netty提供IdleStateHandler,对读写操作进行定时监测, 如果n秒内,ChannelRead()或ChannelWrite没有被调用,则触发userEventTrigger() 用户继承ChannlInboundHandlerAdapter,实现userEventTrigger()方法,可以进行超时后的处理. 用户需要自己实现PING-PONG
连接保活 TCP 中的 KeepAlive 机制。KeepAlive 并不是 TCP 协议的一部分，但是大多数操作系统都实现了这个机制。KeepAlive 机制开启后，在一定时间内(一般时间为 7200s，参数tcp_keepalive_time)在链路上没有数据传送的情况下，TCP 层将发送相应的KeepAlive探针以确定连接可用性，探测失败后重试 10(参数tcp_keepalive_probes)次，每次间隔时间 75s(参数tcp_keepalive_intvl)，所有探测失败后，才认为当前连接已经不可用 应用层心跳.就是客户端会开启一个定时任务，定时对已经建立连接的对端应用发送请求(这里的请求是特殊的心跳请求)，服务端则需要特殊处理该请求，返回响应。如果心跳持续多次没有收到响应，客户端会认为连接不可用，主动断开连接。不同的服务治理框架对心跳，建连，断连，拉黑的机制有不同的策略，但大多数的服务治理框架都会在应用层做心跳，Dubbo 也不例外。以 Dubbo 为例，支持应用层的心跳，客户端和服务端都会开启一个HeartBeatTask，客户端在HeaderExchangeClient中开启，服务端将在HeaderExchangeServer开启。文章开头埋了一个坑：Dubbo 为什么在服务端同时维护Map呢?主要就是为了给心跳做贡献，心跳定时任务在发现连接不可用时，会根据当前是客户端还是服务端走不同的分支，客户端发现不可用，是重连;服务端发现不可用，是直接 close。 业务心跳 + TCP KeepAlive 一起使用，互相作为补充，但 TCP 保活探测周期和应用的心跳周期要协调，以互补方可，不能够差距过大，否则将达不到设想的效果.
发送消息时,网络不稳定造成的影响. 心跳是为了探测链路可用性, 结合重连可以保证当双方进行通信时, 网络尽量是可用的, 而不是断开的. 如果没有实现心跳:
如果网络一直正常,那么连接一直存在. 如果网络出现偶尔波动/闪断, 那么连接也一直存在. 即使闪断瞬间发送消息没有成功, 也会进行多次重试. 所以这种情况下,通信通常都会成功. 如果网络出现长时间断开, 例如网线松动/断电. 默认情况下, 双方不知道连接已经不可用. 这时候发送消息,会失败(如果没有消息应答机制,甚至不知道发送失败). 为了避免第三种情况, 需要进行连接可用性检测与保活重连. 客户端发送心跳,服务端响应, 如果多次没有收到响应,则认为连接不可用,关闭连接, 并进行重连, 如果重连失败, 会多次尝试, 直到重连成功或超过最大重试次数. 服务端一定时间内没有收到客户端发送的心跳, 认为客户端已经断开, 则关闭连接.</description></item><item><title>web实时通信技术方案</title><link>https://barryoo.github.io/web%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/</link><pubDate>Tue, 13 Mar 2018 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/web%E5%AE%9E%E6%97%B6%E9%80%9A%E4%BF%A1%E6%8A%80%E6%9C%AF%E6%96%B9%E6%A1%88/</guid><description>http长轮询 通过延长http响应超时时间.使得服务端可以在一定时间内持有该连接. 当有新消息时,再响应.
servelet3支持异步请求。 springmvc对其进行了支持， 使用DeferredResult
SSE server sent event 基于 WebSocket 协议的一种服务器向客户端发送事件和数据的单向通讯 开发简单，和传统的http开发几乎无任何差别,客户端开发简单,有标准支持 单工通信.只能服务器端向客户端发送数据.
webSocket 在应用层的socket连接.基于TCP/IP. 全双工通信
websocket框架 cometd 实现了http长轮询与webSocket. 可根据客户端的支持程度,自动选择合适的通信技术. netty spring
web push 基于浏览器的notificaitonApi实现. 浏览器向服务商订阅, 得到订阅endpoint. 然后将endpoint发送到服务端. 服务端通过endpoint,发送消息到服务商, 服务商推送消息到浏览器. 国内网络无法使用FCM/GCM/firebase.
HTTP/2 HTTP/2的推送技术,只针对静态资源,且必须是编排好的资源. 不能像websocket一样推送. HTTP/2的推送用于提升网页加载速度. 但是由于没有缓存协商, 会导致网络资源浪费.</description></item></channel></rss>