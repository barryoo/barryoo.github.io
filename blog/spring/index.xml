<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>spring on Barry Blog</title><link>https://barryoo.github.io/blog/spring/</link><description>Recent content in spring on Barry Blog</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><copyright>Copyright © 2023, Barry Chen.</copyright><lastBuildDate>Fri, 10 Mar 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://barryoo.github.io/blog/spring/index.xml" rel="self" type="application/rss+xml"/><item><title>springBoot配置加载顺序</title><link>https://barryoo.github.io/springboot%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</link><pubDate>Fri, 10 Mar 2023 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/springboot%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E9%A1%BA%E5%BA%8F/</guid><description>参考 https://docs.spring.io/spring-boot/docs/2.3.9.RELEASE/reference/htmlsingle/#boot-features-external-config https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.external-config spring2.0与3.0版本的加载顺序不一致, 差异在于config data file的加载顺序不同.
注意: 请以springboot启动流程中配置文件的加载顺序,后加载覆盖先加载来考虑,而不是配置的优先级来考虑. 这样会得到更准确的结果, 也更符合直觉.
PropertySource顺序 加载顺序如下, 下面的覆盖上面的.
Default properties (specified by setting SpringApplication.setDefaultProperties).
@PropertySource annotations on your @Configuration classes. Please note that such property sources are not added to the Environment until the application context is being refreshed. This is too late to configure certain properties such as logging.* and spring.main.* which are read before refresh begins.
Config data (such as application.properties files).</description></item><item><title>springBoot打包容器镜像的多种方式实践</title><link>https://barryoo.github.io/springboot%E6%89%93%E5%8C%85%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E8%B7%B5/</link><pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/springboot%E6%89%93%E5%8C%85%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E8%B7%B5/</guid><description>方式一. maven docker各自运作 使用maven打包为可执行jar包. 编写Dockerfile, 复制jar, 运行jar包. 方式二. maven docker各自运行, 手动分层 使用maven打包为可执行jar包. 解压缩jar包, 并放置到不同层目录中. mkdir -p target/dependency &amp;amp;&amp;amp; (cd target/dependency; jar -xf ../*.jar) 编写Dockerfile, 复制各层的文件, 运行main方法. FROM beevelop/java:latest COPY target/dependency/BOOT-INF/lib /app/lib COPY target/dependency/META-INF /app/META-INF COPY target/dependency/BOOT-INF/classes /app ENTRYPOINT [&amp;#34;java&amp;#34;,&amp;#34;-cp&amp;#34;,&amp;#34;app:app/lib/*&amp;#34;,&amp;#34;com.example.springbootdocker.SpringBootDockerApplication&amp;#34;] 方式三. 在maven执行打包容器镜像. pom.xml中配置容器参数 执行mvn spring-boot:build-image打包. 如果配置了registry, 会自动push 可在pom.xml中配置容器参数. 可在mvn 命令中传入容器参数. docker运行时, 可以通过-e传递springboot运行参数.例如: docker run -e &amp;quot;SPRING_PROFILES_ACTIVE=prod&amp;quot; -p 8080:8080 -t springio/gs-spring-boot-docker
方式四. 在maven执行打包容器镜像, 自动分层. 在spring-boot-maven-plugin中配置layers参数. 本质上只是打包时,添加了一个layers.idx文件.
&amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;layers&amp;gt; &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt; &amp;lt;/layers&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; 实践建议 spring-boot的spring-boot-maven-plugin使用了buildpacker来进行构建镜像, 无需做任何配置, 是最简单的方式, 但是由于国内网络,导致buildpacker相关组件无法下载, 所以该方式不能正常使用.</description></item></channel></rss>