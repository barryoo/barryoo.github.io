<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>云原生 on Barry Blog</title><link>https://barryoo.github.io/blog/%E4%BA%91%E5%8E%9F%E7%94%9F/</link><description>Recent content in 云原生 on Barry Blog</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><copyright>Copyright © 2023, Barry Chen.</copyright><lastBuildDate>Thu, 03 Mar 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://barryoo.github.io/blog/%E4%BA%91%E5%8E%9F%E7%94%9F/index.xml" rel="self" type="application/rss+xml"/><item><title>Serverless简单介绍</title><link>https://barryoo.github.io/serverless%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</link><pubDate>Thu, 03 Mar 2022 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/serverless%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/</guid><description>serverless分为FASS BASS PASS 不是不需要服务器, 而是不需要管理服务器.
核心价值 简化运维 弹性伸缩 按需付费
特点 按需加载 事件驱动 应用无状态 自动弹性伸缩 BASS backend as a service 后端即服务 BaaS提供应用依赖的第三方服务, 如数据库, 缓存, 消息队列, 文件存储, 身份认证, 分析, 云函数等, 通常有云服务商提供, 或者第三方提供. 与PaaS的区别是,PaaS需要使用者管理服务的生命周期, 而BasS只需要使用服务.
FASS function as a server 例如:AWS Lambda，Google Cloud Functions，Azure Functions, alyun FC
面临的问题 难以移植，与云服务商绑定 通常serverless是云服务商提供的, 云服务商的serverless产品不兼容. 服务商提供一系列可供快速使用产品作为服务, 接口通常是专有的,不会与其他服务商兼容. 好在，现在有开源的serverless平台, 各云服务商都可使用。或者使用自定义的container运行时,也可以减少对云服务商的依赖. 缺少控制力 由于用户只需关注代码，也意味着用户无法控制运行的底层环境。 除了代码之外的一切，都发生了质变，意味着工作流程的巨大变化。事实上，代码也变了，如果使用专有的serverless框架，那么对于事件的处理方式，与原方式不同。 调试，测试，应用监控，日志，中间件都与以往不同。 serverless框架 serverless devs 阿里云开源, 支持多云, 支持多语言, 支持多平台, 支持多种运行时. serverless framework AWS Lambda，最早被大众所认可的 Serverless 实现。 Azure Functions，来自微软公有云的 Serverless 实现。 OpenWhisk，Apache 社区的开源 Serverless 框架。 Kubeless，基于 Kubernetes 架构实现的开源 Serverless 框架。 Fission，Platform9 推出的开源 Serverless 框架。 OpenFaaS，以容器技术为核心的开源 Serverless 框架。 Fn，来自 Oracle 的开源 Serverless 框架，由原 Iron Functions 团队开发 FASS详解 概念 服务</description></item><item><title>springBoot打包容器镜像的多种方式实践</title><link>https://barryoo.github.io/springboot%E6%89%93%E5%8C%85%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E8%B7%B5/</link><pubDate>Mon, 10 Jan 2022 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/springboot%E6%89%93%E5%8C%85%E5%AE%B9%E5%99%A8%E9%95%9C%E5%83%8F%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E5%BC%8F%E5%AE%9E%E8%B7%B5/</guid><description>方式一. maven docker各自运作 使用maven打包为可执行jar包. 编写Dockerfile, 复制jar, 运行jar包. 方式二. maven docker各自运行, 手动分层 使用maven打包为可执行jar包. 解压缩jar包, 并放置到不同层目录中. mkdir -p target/dependency &amp;amp;&amp;amp; (cd target/dependency; jar -xf ../*.jar) 编写Dockerfile, 复制各层的文件, 运行main方法. FROM beevelop/java:latest COPY target/dependency/BOOT-INF/lib /app/lib COPY target/dependency/META-INF /app/META-INF COPY target/dependency/BOOT-INF/classes /app ENTRYPOINT [&amp;#34;java&amp;#34;,&amp;#34;-cp&amp;#34;,&amp;#34;app:app/lib/*&amp;#34;,&amp;#34;com.example.springbootdocker.SpringBootDockerApplication&amp;#34;] 方式三. 在maven执行打包容器镜像. pom.xml中配置容器参数 执行mvn spring-boot:build-image打包. 如果配置了registry, 会自动push 可在pom.xml中配置容器参数. 可在mvn 命令中传入容器参数. docker运行时, 可以通过-e传递springboot运行参数.例如: docker run -e &amp;quot;SPRING_PROFILES_ACTIVE=prod&amp;quot; -p 8080:8080 -t springio/gs-spring-boot-docker
方式四. 在maven执行打包容器镜像, 自动分层. 在spring-boot-maven-plugin中配置layers参数. 本质上只是打包时,添加了一个layers.idx文件.
&amp;lt;build&amp;gt; &amp;lt;plugins&amp;gt; &amp;lt;plugin&amp;gt; &amp;lt;groupId&amp;gt;org.springframework.boot&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-boot-maven-plugin&amp;lt;/artifactId&amp;gt; &amp;lt;configuration&amp;gt; &amp;lt;layers&amp;gt; &amp;lt;enabled&amp;gt;true&amp;lt;/enabled&amp;gt; &amp;lt;/layers&amp;gt; &amp;lt;/configuration&amp;gt; &amp;lt;/plugin&amp;gt; &amp;lt;/plugins&amp;gt; &amp;lt;/build&amp;gt; 实践建议 spring-boot的spring-boot-maven-plugin使用了buildpacker来进行构建镜像, 无需做任何配置, 是最简单的方式, 但是由于国内网络,导致buildpacker相关组件无法下载, 所以该方式不能正常使用.</description></item><item><title>docker构建加速</title><link>https://barryoo.github.io/docker%E6%9E%84%E5%BB%BA%E5%8A%A0%E9%80%9F/</link><pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/docker%E6%9E%84%E5%BB%BA%E5%8A%A0%E9%80%9F/</guid><description>https://docs.docker.com/build/cache/
https://juejin.cn/post/7022957854889869325
尽量使用缓存,优先执行没有文件变动的命令,让可缓存的命令在底层.
目标 保持构建环境一致. 最好的方式是使用dockerFile进行构建, 保证jdk和maven版本完全一致. 加速maven打包,以及dockerFile build的速度. maven构建加速 方式1. 提前解决依赖, 则COPY源码进行build copy pom.xml first, executemvn dependency:go-offline, resolve all dependencies, this layer will be cached as long as pom.xml not changed. then copy source code, execute mvn package 在多模块项目中, 可以按照目录结构把父模块和子模块的pom.xml分开COPY, 然后执行mvn dependency:go-offline. 该方案的问题在于:
如果pom.xml文件有变更, 则会导致所有依赖都重新下载, 无法利用缓存. 私仓配置动态传入 方式2. 对构建过程中的依赖进行缓存挂载 RUN --mount=type=cache,target=/root/.m2 mvn clean package -Dmaven.test.skip=true 该样例中对/root/.m2目录进行缓存挂载. 第一次构建时较慢, 因为需要下载所有依赖, 后续构建就会很快, 即使pom.xml文件有变更, 也只会下载变更的依赖.
该方案的问题在于
第一次构建需要下载所有依赖. 私仓配置无法动态传入. 如果需要配置私仓, 则需要自己构建base image, 并在base image中配置私仓, 然后使用该image作为build的基础镜像.</description></item></channel></rss>