<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>docker on Barry Blog</title><link>https://barryoo.github.io/blog/docker/</link><description>Recent content in docker on Barry Blog</description><generator>Hugo -- gohugo.io</generator><language>en-US</language><copyright>Copyright © 2023, Barry Chen.</copyright><lastBuildDate>Mon, 03 Jan 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://barryoo.github.io/blog/docker/index.xml" rel="self" type="application/rss+xml"/><item><title>docker构建加速</title><link>https://barryoo.github.io/docker%E6%9E%84%E5%BB%BA%E5%8A%A0%E9%80%9F/</link><pubDate>Mon, 03 Jan 2022 00:00:00 +0000</pubDate><guid>https://barryoo.github.io/docker%E6%9E%84%E5%BB%BA%E5%8A%A0%E9%80%9F/</guid><description>https://docs.docker.com/build/cache/
https://juejin.cn/post/7022957854889869325
尽量使用缓存,优先执行没有文件变动的命令,让可缓存的命令在底层.
目标 保持构建环境一致. 最好的方式是使用dockerFile进行构建, 保证jdk和maven版本完全一致. 加速maven打包,以及dockerFile build的速度. maven构建加速 方式1. 提前解决依赖, 则COPY源码进行build copy pom.xml first, executemvn dependency:go-offline, resolve all dependencies, this layer will be cached as long as pom.xml not changed. then copy source code, execute mvn package 在多模块项目中, 可以按照目录结构把父模块和子模块的pom.xml分开COPY, 然后执行mvn dependency:go-offline. 该方案的问题在于:
如果pom.xml文件有变更, 则会导致所有依赖都重新下载, 无法利用缓存. 私仓配置动态传入 方式2. 对构建过程中的依赖进行缓存挂载 RUN --mount=type=cache,target=/root/.m2 mvn clean package -Dmaven.test.skip=true 该样例中对/root/.m2目录进行缓存挂载. 第一次构建时较慢, 因为需要下载所有依赖, 后续构建就会很快, 即使pom.xml文件有变更, 也只会下载变更的依赖.
该方案的问题在于
第一次构建需要下载所有依赖. 私仓配置无法动态传入. 如果需要配置私仓, 则需要自己构建base image, 并在base image中配置私仓, 然后使用该image作为build的基础镜像.</description></item></channel></rss>