<!doctype html><html lang=en-US><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://barryoo.github.io/favicon.ico><title>docker构建加速 | Barry Blog</title>
<meta name=title content="docker构建加速"><meta name=description content="https://docs.docker.com/build/cache/
https://juejin.cn/post/7022957854889869325
尽量使用缓存,优先执行没有文件变动的命令,让可缓存的命令在底层.
目标 保持构建环境一致. 最好的方式是使用dockerFile进行构建, 保证jdk和maven版本完全一致. 加速maven打包,以及dockerFile build的速度. maven构建加速 方式1. 提前解决依赖, 则COPY源码进行build copy pom.xml first, executemvn dependency:go-offline, resolve all dependencies, this layer will be cached as long as pom.xml not changed. then copy source code, execute mvn package 在多模块项目中, 可以按照目录结构把父模块和子模块的pom.xml分开COPY, 然后执行mvn dependency:go-offline. 该方案的问题在于:
如果pom.xml文件有变更, 则会导致所有依赖都重新下载, 无法利用缓存. 私仓配置动态传入 方式2. 对构建过程中的依赖进行缓存挂载 RUN --mount=type=cache,target=/root/.m2 mvn clean package -Dmaven.test.skip=true 该样例中对/root/.m2目录进行缓存挂载. 第一次构建时较慢, 因为需要下载所有依赖, 后续构建就会很快, 即使pom.xml文件有变更, 也只会下载变更的依赖.
该方案的问题在于
第一次构建需要下载所有依赖. 私仓配置无法动态传入. 如果需要配置私仓, 则需要自己构建base image, 并在base image中配置私仓, 然后使用该image作为build的基础镜像."><meta name=keywords content="docker,云原生,"><meta property="og:title" content="docker构建加速"><meta property="og:description" content="https://docs.docker.com/build/cache/
https://juejin.cn/post/7022957854889869325
尽量使用缓存,优先执行没有文件变动的命令,让可缓存的命令在底层.
目标 保持构建环境一致. 最好的方式是使用dockerFile进行构建, 保证jdk和maven版本完全一致. 加速maven打包,以及dockerFile build的速度. maven构建加速 方式1. 提前解决依赖, 则COPY源码进行build copy pom.xml first, executemvn dependency:go-offline, resolve all dependencies, this layer will be cached as long as pom.xml not changed. then copy source code, execute mvn package 在多模块项目中, 可以按照目录结构把父模块和子模块的pom.xml分开COPY, 然后执行mvn dependency:go-offline. 该方案的问题在于:
如果pom.xml文件有变更, 则会导致所有依赖都重新下载, 无法利用缓存. 私仓配置动态传入 方式2. 对构建过程中的依赖进行缓存挂载 RUN --mount=type=cache,target=/root/.m2 mvn clean package -Dmaven.test.skip=true 该样例中对/root/.m2目录进行缓存挂载. 第一次构建时较慢, 因为需要下载所有依赖, 后续构建就会很快, 即使pom.xml文件有变更, 也只会下载变更的依赖.
该方案的问题在于
第一次构建需要下载所有依赖. 私仓配置无法动态传入. 如果需要配置私仓, 则需要自己构建base image, 并在base image中配置私仓, 然后使用该image作为build的基础镜像."><meta property="og:type" content="article"><meta property="og:url" content="https://barryoo.github.io/docker%E6%9E%84%E5%BB%BA%E5%8A%A0%E9%80%9F/"><meta property="og:image" content="https://barryoo.github.io/images/share.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2022-01-03T00:00:00+00:00"><meta property="article:modified_time" content="2022-01-03T00:00:00+00:00"><meta property="og:site_name" content="barry blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://barryoo.github.io/images/share.png"><meta name=twitter:title content="docker构建加速"><meta name=twitter:description content="https://docs.docker.com/build/cache/
https://juejin.cn/post/7022957854889869325
尽量使用缓存,优先执行没有文件变动的命令,让可缓存的命令在底层.
目标 保持构建环境一致. 最好的方式是使用dockerFile进行构建, 保证jdk和maven版本完全一致. 加速maven打包,以及dockerFile build的速度. maven构建加速 方式1. 提前解决依赖, 则COPY源码进行build copy pom.xml first, executemvn dependency:go-offline, resolve all dependencies, this layer will be cached as long as pom.xml not changed. then copy source code, execute mvn package 在多模块项目中, 可以按照目录结构把父模块和子模块的pom.xml分开COPY, 然后执行mvn dependency:go-offline. 该方案的问题在于:
如果pom.xml文件有变更, 则会导致所有依赖都重新下载, 无法利用缓存. 私仓配置动态传入 方式2. 对构建过程中的依赖进行缓存挂载 RUN --mount=type=cache,target=/root/.m2 mvn clean package -Dmaven.test.skip=true 该样例中对/root/.m2目录进行缓存挂载. 第一次构建时较慢, 因为需要下载所有依赖, 后续构建就会很快, 即使pom.xml文件有变更, 也只会下载变更的依赖.
该方案的问题在于
第一次构建需要下载所有依赖. 私仓配置无法动态传入. 如果需要配置私仓, 则需要自己构建base image, 并在base image中配置私仓, 然后使用该image作为build的基础镜像."><meta itemprop=name content="docker构建加速"><meta itemprop=description content="https://docs.docker.com/build/cache/
https://juejin.cn/post/7022957854889869325
尽量使用缓存,优先执行没有文件变动的命令,让可缓存的命令在底层.
目标 保持构建环境一致. 最好的方式是使用dockerFile进行构建, 保证jdk和maven版本完全一致. 加速maven打包,以及dockerFile build的速度. maven构建加速 方式1. 提前解决依赖, 则COPY源码进行build copy pom.xml first, executemvn dependency:go-offline, resolve all dependencies, this layer will be cached as long as pom.xml not changed. then copy source code, execute mvn package 在多模块项目中, 可以按照目录结构把父模块和子模块的pom.xml分开COPY, 然后执行mvn dependency:go-offline. 该方案的问题在于:
如果pom.xml文件有变更, 则会导致所有依赖都重新下载, 无法利用缓存. 私仓配置动态传入 方式2. 对构建过程中的依赖进行缓存挂载 RUN --mount=type=cache,target=/root/.m2 mvn clean package -Dmaven.test.skip=true 该样例中对/root/.m2目录进行缓存挂载. 第一次构建时较慢, 因为需要下载所有依赖, 后续构建就会很快, 即使pom.xml文件有变更, 也只会下载变更的依赖.
该方案的问题在于
第一次构建需要下载所有依赖. 私仓配置无法动态传入. 如果需要配置私仓, 则需要自己构建base image, 并在base image中配置私仓, 然后使用该image作为build的基础镜像."><meta itemprop=datePublished content="2022-01-03T00:00:00+00:00"><meta itemprop=dateModified content="2022-01-03T00:00:00+00:00"><meta itemprop=wordCount content="190"><meta itemprop=image content="https://barryoo.github.io/images/share.png"><meta itemprop=keywords content="docker,云原生,"><meta name=referrer content="no-referrer-when-downgrade"><style>html{scroll-behavior:smooth}body{font-family:Verdana,sans-serif;margin:auto;padding:20px;text-align:left;background-color:#fff;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:#444}header{margin:auto;text-align:center;max-width:720px}.menu{justify-content:space-between;display:flex}main{margin:0 auto}.blog-posts-container{width:fit-content;margin:auto}.tag-container{max-width:720px}h1,h2,h3,h4,h5,h6,strong,b{color:#222}a{color:#3273dc}.title{text-decoration:none;border:0;text-align:center;color:#000;font-size:25px}.title span{font-weight:400}nav a{margin-right:10px}textarea{width:100%;font-size:16px}input{font-size:16px}.toc{max-width:250px;width:auto;top:20%;position:fixed;font-size:13px}.toc a{color:rgba(128,128,128,.4);text-decoration:none;display:block}.toc a:hover{color:#777}article{max-width:1080px;margin:0 auto;margin-left:calc(max((100% - 1080px)/2,250px))}content{line-height:1.6}table{width:100%}img{max-width:100%}code{padding:2px 5px;background-color:#f2f2f2}pre code{color:#222;display:block;padding:20px;white-space:pre-wrap;font-size:14px;overflow-x:auto}div.highlight pre{background-color:initial;color:initial}div.highlight code{background-color:unset;color:unset}blockquote{border-left:1px solid #999;color:#222;padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.helptext{color:#777;font-size:small}.errorlist{color:#eba613;font-size:small}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li span{margin-right:30px}ul.blog-posts li a:visited{color:#8b6fcb}@media(prefers-color-scheme:dark){body{background-color:#333;color:#ddd}h1,h2,h3,h4,h5,h6,strong,b{color:#eee}a{color:#8cc2dd}code{background-color:#777}pre code{color:#ddd}blockquote{color:#ccc}textarea,input{background-color:#252525;color:#ddd}.helptext{color:#aaa}}@media only screen and (max-width:1020px){.toc{width:auto;position:relative}article{padding-left:0;margin:0 auto}}</style></head><body><header><nav class=menu><a id=siteTitle href=/ class=title>Barry Blog</a><div style=display:flex><a href=/>Home</a>
<a href=https://github.com/barryOO>github</a>
<a href=/blog/>Blog</a></div></nav></header><main><aside class=toc><a href=#siteTitle style=margin-left:40px>top</a><nav id=TableOfContents><ul><li><a href=#目标>目标</a></li><li><a href=#maven构建加速>maven构建加速</a><ul><li><a href=#方式1-提前解决依赖-则copy源码进行build>方式1. 提前解决依赖, 则COPY源码进行build</a></li><li><a href=#方式2-对构建过程中的依赖进行缓存挂载>方式2. 对构建过程中的依赖进行缓存挂载</a></li><li><a href=#方式3-挂载宿主机的m2目录到build阶段>方式3. 挂载宿主机的.m2目录到build阶段.</a></li><li><a href=#方式4-使用三方构建工具的多阶段构建>方式4. 使用三方构建工具的多阶段构建</a></li><li><a href=#方式5-使用三方构建工具的缓存功能>方式5. 使用三方构建工具的缓存功能</a></li></ul></li><li><a href=#spring-boot-构建加速>spring boot 构建加速</a></li><li><a href=#cicd环境加速>CI/CD环境加速</a></li></ul></nav></aside><article><h1 style=font-size:40px>docker构建加速</h1><p><i><time datetime=2022-01-03 pubdate>03 Jan, 2022</time></i></p><p><a href=https://barryoo.github.io/blog/docker/>#docker</a>
<a href=https://barryoo.github.io/blog/%E4%BA%91%E5%8E%9F%E7%94%9F/>#云原生</a></p><content><p><a href=https://docs.docker.com/build/cache/>https://docs.docker.com/build/cache/</a></p><p><a href=https://juejin.cn/post/7022957854889869325>https://juejin.cn/post/7022957854889869325</a></p><p>尽量使用缓存,优先执行<code>没有文件变动的命令</code>,让可缓存的命令在底层.</p><h2 id=目标>目标</h2><ol><li>保持构建环境一致. 最好的方式是使用dockerFile进行构建, 保证jdk和maven版本完全一致.</li><li>加速maven打包,以及dockerFile build的速度.</li></ol><h2 id=maven构建加速>maven构建加速</h2><h3 id=方式1-提前解决依赖-则copy源码进行build>方式1. 提前解决依赖, 则COPY源码进行build</h3><ul><li>copy pom.xml first, execute<code>mvn dependency:go-offline</code>, resolve all dependencies, this layer will be cached as long as pom.xml not changed.</li><li>then copy source code, execute <code>mvn package</code>
在多模块项目中, 可以按照目录结构把父模块和子模块的pom.xml分开COPY, 然后执行<code>mvn dependency:go-offline</code>.</li></ul><p>该方案的问题在于:</p><ol><li>如果pom.xml文件有变更, 则会导致所有依赖都重新下载, 无法利用缓存.</li><li>私仓配置动态传入</li></ol><h3 id=方式2-对构建过程中的依赖进行缓存挂载>方式2. 对构建过程中的依赖进行缓存挂载</h3><p><code>RUN --mount=type=cache,target=/root/.m2 mvn clean package -Dmaven.test.skip=true </code>该样例中对<code>/root/.m2</code>目录进行缓存挂载.
第一次构建时较慢, 因为需要下载所有依赖, 后续构建就会很快, 即使pom.xml文件有变更, 也只会下载变更的依赖.</p><p>该方案的问题在于</p><ol><li>第一次构建需要下载所有依赖.</li><li>私仓配置无法动态传入.<ol><li>如果需要配置私仓, 则需要自己构建base image, 并在base image中配置私仓, 然后使用该image作为build的基础镜像.</li><li>或者把maven的settings.xml传入, 然后通过<code>mvn -s settings.xml package</code>指定settings.xml运行</li></ol></li></ol><h3 id=方式3-挂载宿主机的m2目录到build阶段><del>方式3. 挂载宿主机的.m2目录到build阶段.</del></h3><blockquote><p>该方案不可行, 因为.m2必须在dockerfile context中才能进行挂载, 但是把.m2放在context中会导致上下文非常大, 这会有性能问题. 另外在使用远程docker engine时,会把context传输到远程docker engine, context太大会导致问题.</p></blockquote><p><code>RUN --mount=type=bind,source=,target=/Users/chen/.m2 mvn clean package -Dmaven.test.skip=true</code></p><p>该问题目前在讨论中, 没有结果: <a href=https://github.com/moby/buildkit/issues/1512>https://github.com/moby/buildkit/issues/1512</a></p><h3 id=方式4-使用三方构建工具的多阶段构建>方式4. 使用三方构建工具的多阶段构建</h3><p>例如shell脚本 jenkins gitlab-ci, 把maven构建和docker构建分开.</p><ol><li>启动容器进行maven构建, 在<code>docker run </code>时, 可以挂载宿主机的.m2目录到容器中, 这样就可以利用宿主机的.m2缓存.</li><li>把maven构建的产物复制到docker构建中.</li><li>启动另外一个容器进行docker镜像构建.</li></ol><h3 id=方式5-使用三方构建工具的缓存功能>方式5. 使用三方构建工具的缓存功能</h3><p>例如gitlab-ci, 可以通过指定cache,来缓存相应的目录.</p><h2 id=spring-boot-构建加速>spring boot 构建加速</h2><ul><li>unpack and layering the packaged jar</li><li>then copy every layer to docker image.</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span><span style=color:#75715e># jar包解压为多层</span>
</span></span><span style=display:flex><span>java -Djarmode<span style=color:#f92672>=</span>layertools -jar helloworld-controller/target/*.jar extract --destination helloworld-controller/target/extracted
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-dockerfile data-lang=dockerfile><span style=display:flex><span><span style=color:#66d9ef>FROM</span><span style=color:#e6db74> ibm-semeru-runtimes:open-8u362-b09-jre-centos7</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>WORKDIR</span><span style=color:#e6db74> /app</span><span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ARG</span> EXTRACTED<span style=color:#f92672>=</span>/workspace/app/helloworld-controller/target/extracted<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>build <span style=color:#e6db74>${</span>EXTRACTED<span style=color:#e6db74>}</span>/dependencies/ ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>build <span style=color:#e6db74>${</span>EXTRACTED<span style=color:#e6db74>}</span>/spring-boot-loader/ ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>build <span style=color:#e6db74>${</span>EXTRACTED<span style=color:#e6db74>}</span>/company-dependencies/ ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>build <span style=color:#e6db74>${</span>EXTRACTED<span style=color:#e6db74>}</span>/snapshot-dependencies/ ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>COPY</span> --from<span style=color:#f92672>=</span>build <span style=color:#e6db74>${</span>EXTRACTED<span style=color:#e6db74>}</span>/application/ ./<span style=color:#960050;background-color:#1e0010>
</span></span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010></span><span style=color:#66d9ef>ENTRYPOINT</span> [<span style=color:#e6db74>&#34;java&#34;</span>,<span style=color:#e6db74>&#34;org.springframework.boot.loader.JarLauncher&#34;</span>]<span style=color:#960050;background-color:#1e0010>
</span></span></span></code></pre></div><h2 id=cicd环境加速>CI/CD环境加速</h2><p>在CI/CD中每次构建都会申请一个全新的环境进行构建,也意味着docker build的layer缓存无法被重复利用.</p><p>通过 <code>Cache backend</code>可以对构建缓存进行导入和导出</p><p><a href=https://docs.docker.com/build/cache/backends/>Cache storage backends | Docker Documentation</a></p><blockquote><p>该功能不能代替<code>--mount=type=cache/bind</code>, 它们的目的完全不同.</p><ul><li><code>–-mount</code>用于对构建中产生的产物相关数据进行缓存,这些数据与容器技术无关. 例如maven/npm 依赖. 即使该层的文件或命令发生变动, 缓存也不会失效.</li><li><code>Cache backend</code>用于对构建中产品的容器相关layer进行缓存, 事实上, 如果该层的文件或命令发生变动,该层缓存会完全失效.</li></ul></blockquote></content></article></main><footer></footer></body></html>