<!doctype html><html lang=en-US><head><meta http-equiv=X-Clacks-Overhead content="GNU Terry Pratchett"><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><link rel="shortcut icon" href=https://barryoo.github.io/favicon.ico><title>连接保活 | Barry Blog</title>
<meta name=title content="连接保活"><meta name=description content="链路可用性检测 TCP连接是虚拟的. 两个状态机同时维护满足逻辑上认为是连接的状态,我们称之为连接. socket连接 是通过双方分别对IP和Port进行监听, 而实现的实时通信. 所以socket对连接是否畅通是无感知的. 如果网络没有问题, 则连接永远存在,不会断开. 当网络不稳定时,双方需要知道对方是否还在,则需要通过发送消息/ACK,来确认.所以心跳是为了确认连接是否还在.
Netty提供IdleStateHandler,对读写操作进行定时监测, 如果n秒内,ChannelRead()或ChannelWrite没有被调用,则触发userEventTrigger() 用户继承ChannlInboundHandlerAdapter,实现userEventTrigger()方法,可以进行超时后的处理. 用户需要自己实现PING-PONG
连接保活 TCP 中的 KeepAlive 机制。KeepAlive 并不是 TCP 协议的一部分，但是大多数操作系统都实现了这个机制。KeepAlive 机制开启后，在一定时间内(一般时间为 7200s，参数tcp_keepalive_time)在链路上没有数据传送的情况下，TCP 层将发送相应的KeepAlive探针以确定连接可用性，探测失败后重试 10(参数tcp_keepalive_probes)次，每次间隔时间 75s(参数tcp_keepalive_intvl)，所有探测失败后，才认为当前连接已经不可用 应用层心跳.就是客户端会开启一个定时任务，定时对已经建立连接的对端应用发送请求(这里的请求是特殊的心跳请求)，服务端则需要特殊处理该请求，返回响应。如果心跳持续多次没有收到响应，客户端会认为连接不可用，主动断开连接。不同的服务治理框架对心跳，建连，断连，拉黑的机制有不同的策略，但大多数的服务治理框架都会在应用层做心跳，Dubbo 也不例外。以 Dubbo 为例，支持应用层的心跳，客户端和服务端都会开启一个HeartBeatTask，客户端在HeaderExchangeClient中开启，服务端将在HeaderExchangeServer开启。文章开头埋了一个坑：Dubbo 为什么在服务端同时维护Map呢?主要就是为了给心跳做贡献，心跳定时任务在发现连接不可用时，会根据当前是客户端还是服务端走不同的分支，客户端发现不可用，是重连;服务端发现不可用，是直接 close。 业务心跳 + TCP KeepAlive 一起使用，互相作为补充，但 TCP 保活探测周期和应用的心跳周期要协调，以互补方可，不能够差距过大，否则将达不到设想的效果.
发送消息时,网络不稳定造成的影响. 心跳是为了探测链路可用性, 结合重连可以保证当双方进行通信时, 网络尽量是可用的, 而不是断开的. 如果没有实现心跳:
如果网络一直正常,那么连接一直存在. 如果网络出现偶尔波动/闪断, 那么连接也一直存在. 即使闪断瞬间发送消息没有成功, 也会进行多次重试. 所以这种情况下,通信通常都会成功. 如果网络出现长时间断开, 例如网线松动/断电. 默认情况下, 双方不知道连接已经不可用. 这时候发送消息,会失败(如果没有消息应答机制,甚至不知道发送失败). 为了避免第三种情况, 需要进行连接可用性检测与保活重连. 客户端发送心跳,服务端响应, 如果多次没有收到响应,则认为连接不可用,关闭连接, 并进行重连, 如果重连失败, 会多次尝试, 直到重连成功或超过最大重试次数. 服务端一定时间内没有收到客户端发送的心跳, 认为客户端已经断开, 则关闭连接. "><meta name=keywords content="保活,心跳,Netty,"><meta property="og:title" content="连接保活"><meta property="og:description" content="链路可用性检测 TCP连接是虚拟的. 两个状态机同时维护满足逻辑上认为是连接的状态,我们称之为连接. socket连接 是通过双方分别对IP和Port进行监听, 而实现的实时通信. 所以socket对连接是否畅通是无感知的. 如果网络没有问题, 则连接永远存在,不会断开. 当网络不稳定时,双方需要知道对方是否还在,则需要通过发送消息/ACK,来确认.所以心跳是为了确认连接是否还在.
Netty提供IdleStateHandler,对读写操作进行定时监测, 如果n秒内,ChannelRead()或ChannelWrite没有被调用,则触发userEventTrigger() 用户继承ChannlInboundHandlerAdapter,实现userEventTrigger()方法,可以进行超时后的处理. 用户需要自己实现PING-PONG
连接保活 TCP 中的 KeepAlive 机制。KeepAlive 并不是 TCP 协议的一部分，但是大多数操作系统都实现了这个机制。KeepAlive 机制开启后，在一定时间内(一般时间为 7200s，参数tcp_keepalive_time)在链路上没有数据传送的情况下，TCP 层将发送相应的KeepAlive探针以确定连接可用性，探测失败后重试 10(参数tcp_keepalive_probes)次，每次间隔时间 75s(参数tcp_keepalive_intvl)，所有探测失败后，才认为当前连接已经不可用 应用层心跳.就是客户端会开启一个定时任务，定时对已经建立连接的对端应用发送请求(这里的请求是特殊的心跳请求)，服务端则需要特殊处理该请求，返回响应。如果心跳持续多次没有收到响应，客户端会认为连接不可用，主动断开连接。不同的服务治理框架对心跳，建连，断连，拉黑的机制有不同的策略，但大多数的服务治理框架都会在应用层做心跳，Dubbo 也不例外。以 Dubbo 为例，支持应用层的心跳，客户端和服务端都会开启一个HeartBeatTask，客户端在HeaderExchangeClient中开启，服务端将在HeaderExchangeServer开启。文章开头埋了一个坑：Dubbo 为什么在服务端同时维护Map呢?主要就是为了给心跳做贡献，心跳定时任务在发现连接不可用时，会根据当前是客户端还是服务端走不同的分支，客户端发现不可用，是重连;服务端发现不可用，是直接 close。 业务心跳 + TCP KeepAlive 一起使用，互相作为补充，但 TCP 保活探测周期和应用的心跳周期要协调，以互补方可，不能够差距过大，否则将达不到设想的效果.
发送消息时,网络不稳定造成的影响. 心跳是为了探测链路可用性, 结合重连可以保证当双方进行通信时, 网络尽量是可用的, 而不是断开的. 如果没有实现心跳:
如果网络一直正常,那么连接一直存在. 如果网络出现偶尔波动/闪断, 那么连接也一直存在. 即使闪断瞬间发送消息没有成功, 也会进行多次重试. 所以这种情况下,通信通常都会成功. 如果网络出现长时间断开, 例如网线松动/断电. 默认情况下, 双方不知道连接已经不可用. 这时候发送消息,会失败(如果没有消息应答机制,甚至不知道发送失败). 为了避免第三种情况, 需要进行连接可用性检测与保活重连. 客户端发送心跳,服务端响应, 如果多次没有收到响应,则认为连接不可用,关闭连接, 并进行重连, 如果重连失败, 会多次尝试, 直到重连成功或超过最大重试次数. 服务端一定时间内没有收到客户端发送的心跳, 认为客户端已经断开, 则关闭连接. "><meta property="og:type" content="article"><meta property="og:url" content="https://barryoo.github.io/%E8%BF%9E%E6%8E%A5%E4%BF%9D%E6%B4%BB/"><meta property="og:image" content="https://barryoo.github.io/images/share.png"><meta property="article:section" content="blog"><meta property="article:published_time" content="2019-04-09T00:00:00+00:00"><meta property="article:modified_time" content="2019-04-09T00:00:00+00:00"><meta property="og:site_name" content="barry blog"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://barryoo.github.io/images/share.png"><meta name=twitter:title content="连接保活"><meta name=twitter:description content="链路可用性检测 TCP连接是虚拟的. 两个状态机同时维护满足逻辑上认为是连接的状态,我们称之为连接. socket连接 是通过双方分别对IP和Port进行监听, 而实现的实时通信. 所以socket对连接是否畅通是无感知的. 如果网络没有问题, 则连接永远存在,不会断开. 当网络不稳定时,双方需要知道对方是否还在,则需要通过发送消息/ACK,来确认.所以心跳是为了确认连接是否还在.
Netty提供IdleStateHandler,对读写操作进行定时监测, 如果n秒内,ChannelRead()或ChannelWrite没有被调用,则触发userEventTrigger() 用户继承ChannlInboundHandlerAdapter,实现userEventTrigger()方法,可以进行超时后的处理. 用户需要自己实现PING-PONG
连接保活 TCP 中的 KeepAlive 机制。KeepAlive 并不是 TCP 协议的一部分，但是大多数操作系统都实现了这个机制。KeepAlive 机制开启后，在一定时间内(一般时间为 7200s，参数tcp_keepalive_time)在链路上没有数据传送的情况下，TCP 层将发送相应的KeepAlive探针以确定连接可用性，探测失败后重试 10(参数tcp_keepalive_probes)次，每次间隔时间 75s(参数tcp_keepalive_intvl)，所有探测失败后，才认为当前连接已经不可用 应用层心跳.就是客户端会开启一个定时任务，定时对已经建立连接的对端应用发送请求(这里的请求是特殊的心跳请求)，服务端则需要特殊处理该请求，返回响应。如果心跳持续多次没有收到响应，客户端会认为连接不可用，主动断开连接。不同的服务治理框架对心跳，建连，断连，拉黑的机制有不同的策略，但大多数的服务治理框架都会在应用层做心跳，Dubbo 也不例外。以 Dubbo 为例，支持应用层的心跳，客户端和服务端都会开启一个HeartBeatTask，客户端在HeaderExchangeClient中开启，服务端将在HeaderExchangeServer开启。文章开头埋了一个坑：Dubbo 为什么在服务端同时维护Map呢?主要就是为了给心跳做贡献，心跳定时任务在发现连接不可用时，会根据当前是客户端还是服务端走不同的分支，客户端发现不可用，是重连;服务端发现不可用，是直接 close。 业务心跳 + TCP KeepAlive 一起使用，互相作为补充，但 TCP 保活探测周期和应用的心跳周期要协调，以互补方可，不能够差距过大，否则将达不到设想的效果.
发送消息时,网络不稳定造成的影响. 心跳是为了探测链路可用性, 结合重连可以保证当双方进行通信时, 网络尽量是可用的, 而不是断开的. 如果没有实现心跳:
如果网络一直正常,那么连接一直存在. 如果网络出现偶尔波动/闪断, 那么连接也一直存在. 即使闪断瞬间发送消息没有成功, 也会进行多次重试. 所以这种情况下,通信通常都会成功. 如果网络出现长时间断开, 例如网线松动/断电. 默认情况下, 双方不知道连接已经不可用. 这时候发送消息,会失败(如果没有消息应答机制,甚至不知道发送失败). 为了避免第三种情况, 需要进行连接可用性检测与保活重连. 客户端发送心跳,服务端响应, 如果多次没有收到响应,则认为连接不可用,关闭连接, 并进行重连, 如果重连失败, 会多次尝试, 直到重连成功或超过最大重试次数. 服务端一定时间内没有收到客户端发送的心跳, 认为客户端已经断开, 则关闭连接. "><meta itemprop=name content="连接保活"><meta itemprop=description content="链路可用性检测 TCP连接是虚拟的. 两个状态机同时维护满足逻辑上认为是连接的状态,我们称之为连接. socket连接 是通过双方分别对IP和Port进行监听, 而实现的实时通信. 所以socket对连接是否畅通是无感知的. 如果网络没有问题, 则连接永远存在,不会断开. 当网络不稳定时,双方需要知道对方是否还在,则需要通过发送消息/ACK,来确认.所以心跳是为了确认连接是否还在.
Netty提供IdleStateHandler,对读写操作进行定时监测, 如果n秒内,ChannelRead()或ChannelWrite没有被调用,则触发userEventTrigger() 用户继承ChannlInboundHandlerAdapter,实现userEventTrigger()方法,可以进行超时后的处理. 用户需要自己实现PING-PONG
连接保活 TCP 中的 KeepAlive 机制。KeepAlive 并不是 TCP 协议的一部分，但是大多数操作系统都实现了这个机制。KeepAlive 机制开启后，在一定时间内(一般时间为 7200s，参数tcp_keepalive_time)在链路上没有数据传送的情况下，TCP 层将发送相应的KeepAlive探针以确定连接可用性，探测失败后重试 10(参数tcp_keepalive_probes)次，每次间隔时间 75s(参数tcp_keepalive_intvl)，所有探测失败后，才认为当前连接已经不可用 应用层心跳.就是客户端会开启一个定时任务，定时对已经建立连接的对端应用发送请求(这里的请求是特殊的心跳请求)，服务端则需要特殊处理该请求，返回响应。如果心跳持续多次没有收到响应，客户端会认为连接不可用，主动断开连接。不同的服务治理框架对心跳，建连，断连，拉黑的机制有不同的策略，但大多数的服务治理框架都会在应用层做心跳，Dubbo 也不例外。以 Dubbo 为例，支持应用层的心跳，客户端和服务端都会开启一个HeartBeatTask，客户端在HeaderExchangeClient中开启，服务端将在HeaderExchangeServer开启。文章开头埋了一个坑：Dubbo 为什么在服务端同时维护Map呢?主要就是为了给心跳做贡献，心跳定时任务在发现连接不可用时，会根据当前是客户端还是服务端走不同的分支，客户端发现不可用，是重连;服务端发现不可用，是直接 close。 业务心跳 + TCP KeepAlive 一起使用，互相作为补充，但 TCP 保活探测周期和应用的心跳周期要协调，以互补方可，不能够差距过大，否则将达不到设想的效果.
发送消息时,网络不稳定造成的影响. 心跳是为了探测链路可用性, 结合重连可以保证当双方进行通信时, 网络尽量是可用的, 而不是断开的. 如果没有实现心跳:
如果网络一直正常,那么连接一直存在. 如果网络出现偶尔波动/闪断, 那么连接也一直存在. 即使闪断瞬间发送消息没有成功, 也会进行多次重试. 所以这种情况下,通信通常都会成功. 如果网络出现长时间断开, 例如网线松动/断电. 默认情况下, 双方不知道连接已经不可用. 这时候发送消息,会失败(如果没有消息应答机制,甚至不知道发送失败). 为了避免第三种情况, 需要进行连接可用性检测与保活重连. 客户端发送心跳,服务端响应, 如果多次没有收到响应,则认为连接不可用,关闭连接, 并进行重连, 如果重连失败, 会多次尝试, 直到重连成功或超过最大重试次数. 服务端一定时间内没有收到客户端发送的心跳, 认为客户端已经断开, 则关闭连接. "><meta itemprop=datePublished content="2019-04-09T00:00:00+00:00"><meta itemprop=dateModified content="2019-04-09T00:00:00+00:00"><meta itemprop=wordCount content="68"><meta itemprop=image content="https://barryoo.github.io/images/share.png"><meta itemprop=keywords content="保活,心跳,Netty,"><meta name=referrer content="no-referrer-when-downgrade"><style>html{scroll-behavior:smooth}body{font-family:Verdana,sans-serif;margin:auto;padding:20px;text-align:left;background-color:#fff;word-wrap:break-word;overflow-wrap:break-word;line-height:1.5;color:#444}header{margin:auto;text-align:center;max-width:720px}.menu{justify-content:space-between;display:flex}main{margin:0 auto}.blog-posts-container{width:fit-content;margin:auto}.tag-container{max-width:720px}h1,h2,h3,h4,h5,h6,strong,b{color:#222}a{color:#3273dc}.title{text-decoration:none;border:0;text-align:center;color:#000;font-size:25px}.title span{font-weight:400}nav a{margin-right:10px}textarea{width:100%;font-size:16px}input{font-size:16px}.toc{max-width:250px;width:auto;top:20%;position:fixed;font-size:13px}.toc a{color:rgba(128,128,128,.4);text-decoration:none;display:block}.toc a:hover{color:#777}article{max-width:1080px;margin:0 auto;margin-left:calc(max((100% - 1080px)/2,250px))}content{line-height:1.6}table{width:100%}img{max-width:100%}code{padding:2px 5px;background-color:#f2f2f2}pre code{color:#222;display:block;padding:20px;white-space:pre-wrap;font-size:14px;overflow-x:auto}div.highlight pre{background-color:initial;color:initial}div.highlight code{background-color:unset;color:unset}blockquote{border-left:1px solid #999;color:#222;padding-left:20px;font-style:italic}footer{padding:25px;text-align:center}.helptext{color:#777;font-size:small}.errorlist{color:#eba613;font-size:small}ul.blog-posts{list-style-type:none;padding:unset}ul.blog-posts li span{margin-right:30px}ul.blog-posts li a:visited{color:#8b6fcb}@media(prefers-color-scheme:dark){body{background-color:#333;color:#ddd}h1,h2,h3,h4,h5,h6,strong,b{color:#eee}a{color:#8cc2dd}code{background-color:#777}pre code{color:#ddd}blockquote{color:#ccc}textarea,input{background-color:#252525;color:#ddd}.helptext{color:#aaa}}@media only screen and (max-width:1020px){.toc{width:auto;position:relative}article{padding-left:0;margin:0 auto}}</style></head><body><header><nav class=menu><a id=siteTitle href=/ class=title>Barry Blog</a><div style=display:flex><a href=/>Home</a>
<a href=https://github.com/barryOO>github</a>
<a href=/blog/>Blog</a></div></nav></header><main><aside class=toc><a href=#siteTitle style=margin-left:40px>top</a><nav id=TableOfContents><ul><li><a href=#链路可用性检测>链路可用性检测</a></li><li><a href=#连接保活>连接保活</a></li><li><a href=#发送消息时网络不稳定造成的影响>发送消息时,网络不稳定造成的影响.</a></li></ul></nav></aside><article><h1 style=font-size:40px>连接保活</h1><p><i><time datetime=2019-04-09 pubdate>09 Apr, 2019</time></i></p><p><a href=https://barryoo.github.io/blog/%E4%BF%9D%E6%B4%BB/>#保活</a>
<a href=https://barryoo.github.io/blog/%E5%BF%83%E8%B7%B3/>#心跳</a>
<a href=https://barryoo.github.io/blog/netty/>#Netty</a></p><content><h2 id=链路可用性检测>链路可用性检测</h2><p>TCP连接是虚拟的. 两个状态机同时维护满足逻辑上认为是连接的状态,我们称之为连接.
socket连接 是通过双方分别对IP和Port进行监听, 而实现的实时通信. 所以socket对连接是否畅通是无感知的.
如果网络没有问题, 则连接永远存在,不会断开.
当网络不稳定时,双方需要知道对方是否还在,则需要通过发送消息/ACK,来确认.所以心跳是为了确认连接是否还在.</p><p>Netty提供<code>IdleStateHandler</code>,对读写操作进行定时监测, 如果n秒内,<code>ChannelRead()</code>或<code>ChannelWrite</code>没有被调用,则触发<code>userEventTrigger()</code>
用户继承<code>ChannlInboundHandlerAdapter</code>,实现<code>userEventTrigger()</code>方法,可以进行超时后的处理.
用户需要自己实现PING-PONG</p><h2 id=连接保活>连接保活</h2><ol><li>TCP 中的 KeepAlive 机制。KeepAlive 并不是 TCP 协议的一部分，但是大多数操作系统都实现了这个机制。KeepAlive 机制开启后，在一定时间内(一般时间为 7200s，参数tcp_keepalive_time)在链路上没有数据传送的情况下，TCP 层将发送相应的KeepAlive探针以确定连接可用性，探测失败后重试 10(参数tcp_keepalive_probes)次，每次间隔时间 75s(参数tcp_keepalive_intvl)，所有探测失败后，才认为当前连接已经不可用</li><li>应用层心跳.就是客户端会开启一个定时任务，定时对已经建立连接的对端应用发送请求(这里的请求是特殊的心跳请求)，服务端则需要特殊处理该请求，返回响应。如果心跳持续多次没有收到响应，客户端会认为连接不可用，主动断开连接。不同的服务治理框架对心跳，建连，断连，拉黑的机制有不同的策略，但大多数的服务治理框架都会在应用层做心跳，Dubbo 也不例外。以 Dubbo 为例，支持应用层的心跳，客户端和服务端都会开启一个HeartBeatTask，客户端在HeaderExchangeClient中开启，服务端将在HeaderExchangeServer开启。文章开头埋了一个坑：Dubbo 为什么在服务端同时维护Map呢?主要就是为了给心跳做贡献，心跳定时任务在发现连接不可用时，会根据当前是客户端还是服务端走不同的分支，客户端发现不可用，是重连;服务端发现不可用，是直接 close。</li></ol><p>业务心跳 + TCP KeepAlive 一起使用，互相作为补充，但 TCP 保活探测周期和应用的心跳周期要协调，以互补方可，不能够差距过大，否则将达不到设想的效果.</p><h2 id=发送消息时网络不稳定造成的影响>发送消息时,网络不稳定造成的影响.</h2><p>心跳是为了探测链路可用性, 结合重连可以保证当双方进行通信时, 网络<code>尽量</code>是可用的, 而不是断开的.
如果没有实现心跳:</p><ul><li>如果网络一直正常,那么连接一直存在.</li><li>如果网络出现偶尔波动/闪断, 那么连接也一直存在. 即使闪断瞬间发送消息没有成功, 也会进行多次重试. 所以这种情况下,通信通常都会成功.</li><li>如果网络出现长时间断开, 例如网线松动/断电. 默认情况下, 双方不知道连接已经不可用. 这时候发送消息,会失败(如果没有消息应答机制,甚至不知道发送失败).
为了避免第三种情况, 需要进行连接可用性检测与保活重连.</li><li>客户端发送心跳,服务端响应, 如果多次没有收到响应,则认为连接不可用,关闭连接, 并进行重连, 如果重连失败, 会多次尝试, 直到重连成功或超过最大重试次数.</li><li>服务端一定时间内没有收到客户端发送的心跳, 认为客户端已经断开, 则关闭连接.</li></ul></content></article></main><footer></footer></body></html>